

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tskit.trees &mdash; tskit 0.3.3.dev1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> tskit
          

          
            
            <img src="../../_static/tskit_logo_pale.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data-model.html">Data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../combinatorics.html">Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelogs.html">Changelogs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tskit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tskit.trees</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tskit.trees</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># MIT License</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018-2020 Tskit Developers</span>
<span class="c1"># Copyright (c) 2015-2018 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module responsible for managing trees and tree sequences.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">_tskit</span>
<span class="kn">import</span> <span class="nn">tskit.combinatorics</span> <span class="k">as</span> <span class="nn">combinatorics</span>
<span class="kn">import</span> <span class="nn">tskit.drawing</span> <span class="k">as</span> <span class="nn">drawing</span>
<span class="kn">import</span> <span class="nn">tskit.exceptions</span> <span class="k">as</span> <span class="nn">exceptions</span>
<span class="kn">import</span> <span class="nn">tskit.formats</span> <span class="k">as</span> <span class="nn">formats</span>
<span class="kn">import</span> <span class="nn">tskit.metadata</span> <span class="k">as</span> <span class="nn">metadata_module</span>
<span class="kn">import</span> <span class="nn">tskit.tables</span> <span class="k">as</span> <span class="nn">tables</span>
<span class="kn">import</span> <span class="nn">tskit.util</span> <span class="k">as</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">tskit.vcf</span> <span class="k">as</span> <span class="nn">vcf</span>
<span class="kn">from</span> <span class="nn">tskit</span> <span class="kn">import</span> <span class="n">NODE_IS_SAMPLE</span>
<span class="kn">from</span> <span class="nn">tskit</span> <span class="kn">import</span> <span class="n">NULL</span>
<span class="kn">from</span> <span class="nn">tskit</span> <span class="kn">import</span> <span class="n">UNKNOWN_TIME</span>


<span class="n">CoalescenceRecord</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;CoalescenceRecord&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">BaseInterval</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;BaseInterval&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">])</span>


<div class="viewcode-block" id="Interval"><a class="viewcode-back" href="../../python-api.html#tskit.Interval">[docs]</a><span class="k">class</span> <span class="nc">Interval</span><span class="p">(</span><span class="n">BaseInterval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A tuple of 2 numbers, ``[left, right)``, defining an interval over the genome.</span>

<span class="sd">    :ivar left: The left hand end of the interval. By convention this value is included</span>
<span class="sd">        in the interval.</span>
<span class="sd">    :vartype left: float</span>
<span class="sd">    :ivar right: The right hand end of the iterval. By convention this value is *not*</span>
<span class="sd">        included in the interval, i.e. the interval is half-open.</span>
<span class="sd">    :vartype right: float</span>
<span class="sd">    :ivar span: The span of the genome covered by this interval, simply ``right-left``.</span>
<span class="sd">    :vartype span: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span></div>


<span class="c1"># TODO this interface is rubbish. Should have much better printing options.</span>
<span class="c1"># TODO we should be use __slots__ here probably.</span>
<span class="k">class</span> <span class="nc">SimpleContainer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SimpleContainerWithMetadata</span><span class="p">(</span><span class="n">SimpleContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class allows metadata to be lazily decoded and cached</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">CachedMetadata</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we had python&gt;=3.8 we could just use @functools.cached_property here. We</span>
<span class="sd">        don&#39;t so we implement it similarly using a descriptor</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;SimpleContainerWithMetadata&quot;</span><span class="p">,</span> <span class="n">owner</span><span class="p">:</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">_metadata_decoder</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">_encoded_metadata</span><span class="p">)</span>
            <span class="n">container</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decoded</span>
            <span class="k">return</span> <span class="n">decoded</span>

    <span class="n">metadata</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">CachedMetadata</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SimpleContainer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># We need to remove metadata and the decoder so we are just comparing</span>
        <span class="c1"># the encoded metadata, along with the other attributes</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">}</span>
        <span class="n">other</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">other</span><span class="p">[</span><span class="s2">&quot;_metadata_decoder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">self_</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">}</span>
        <span class="n">self_</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">self_</span><span class="p">[</span><span class="s2">&quot;_metadata_decoder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">self_</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Make sure we have a decoded metadata</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">}</span>
        <span class="k">del</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;_encoded_metadata&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;_metadata_decoder&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<div class="viewcode-block" id="Individual"><a class="viewcode-back" href="../../python-api.html#tskit.Individual">[docs]</a><span class="k">class</span> <span class="nc">Individual</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :ref:`individual &lt;sec_individual_table_definition&gt;` in a tree sequence.</span>
<span class="sd">    Since nodes correspond to genomes, individuals are associated with a collection</span>
<span class="sd">    of nodes (e.g., two nodes per diploid). See :ref:`sec_nodes_or_individuals`</span>
<span class="sd">    for more discussion of this distinction.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar id: The integer ID of this individual. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_individuals` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar flags: The bitwise flags for this individual.</span>
<span class="sd">    :vartype flags: int</span>
<span class="sd">    :ivar location: The spatial location of this individual as a numpy array. The</span>
<span class="sd">        location is an empty array if no spatial location is defined.</span>
<span class="sd">    :vartype location: numpy.ndarray</span>
<span class="sd">    :ivar nodes: The IDs of the nodes that are associated with this individual as</span>
<span class="sd">        a numpy array (dtype=np.int32). If no nodes are associated with the</span>
<span class="sd">        individual this array will be empty.</span>
<span class="sd">    :vartype location: numpy.ndarray</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;`</span>
<span class="sd">         for this individual.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">flags</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_encoded_metadata</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../python-api.html#tskit.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`node &lt;sec_node_table_definition&gt;` in a tree sequence, corresponding</span>
<span class="sd">    to a single genome. The ``time`` and ``population`` are attributes of the</span>
<span class="sd">    ``Node``, rather than the ``Individual``, as discussed in</span>
<span class="sd">    :ref:`sec_nodes_or_individuals`.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar id: The integer ID of this node. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_nodes` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar flags: The bitwise flags for this node.</span>
<span class="sd">    :vartype flags: int</span>
<span class="sd">    :ivar time: The birth time of this node.</span>
<span class="sd">    :vartype time: float</span>
<span class="sd">    :ivar population: The integer ID of the population that this node was born in.</span>
<span class="sd">    :vartype population: int</span>
<span class="sd">    :ivar individual: The integer ID of the individual that this node was a part of.</span>
<span class="sd">    :vartype individual: int</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;` for this node.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">population</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">individual</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">population</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individual</span> <span class="o">=</span> <span class="n">individual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

<div class="viewcode-block" id="Node.is_sample"><a class="viewcode-back" href="../../python-api.html#tskit.Node.is_sample">[docs]</a>    <span class="k">def</span> <span class="nf">is_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this node is a sample. This value is derived from the</span>
<span class="sd">        ``flag`` variable.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NODE_IS_SAMPLE</span></div></div>


<div class="viewcode-block" id="Edge"><a class="viewcode-back" href="../../python-api.html#tskit.Edge">[docs]</a><span class="k">class</span> <span class="nc">Edge</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :ref:`edge &lt;sec_edge_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar left: The left coordinate of this edge.</span>
<span class="sd">    :vartype left: float</span>
<span class="sd">    :ivar right: The right coordinate of this edge.</span>
<span class="sd">    :vartype right: float</span>
<span class="sd">    :ivar parent: The integer ID of the parent node for this edge.</span>
<span class="sd">        To obtain further information about a node with a given ID, use</span>
<span class="sd">        :meth:`TreeSequence.node`.</span>
<span class="sd">    :vartype parent: int</span>
<span class="sd">    :ivar child: The integer ID of the child node for this edge.</span>
<span class="sd">        To obtain further information about a node with a given ID, use</span>
<span class="sd">        :meth:`TreeSequence.node`.</span>
<span class="sd">    :vartype child: int</span>
<span class="sd">    :ivar id: The integer ID of this edge. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_edges` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;` for this edge.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">,</span>
        <span class="n">child</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;{{left=</span><span class="si">{:.3f}</span><span class="s2">, right=</span><span class="si">{:.3f}</span><span class="s2">, parent=</span><span class="si">{}</span><span class="s2">, child=</span><span class="si">{}</span><span class="s2">, id=</span><span class="si">{}</span><span class="s2">, &quot;</span>
            <span class="s2">&quot;metadata=</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the span of this edge, i.e. the right position minus the left position</span>

<span class="sd">        :return: The span of this edge.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span></div>


<div class="viewcode-block" id="Site"><a class="viewcode-back" href="../../python-api.html#tskit.Site">[docs]</a><span class="k">class</span> <span class="nc">Site</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`site &lt;sec_site_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar id: The integer ID of this site. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_sites` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar position: The floating point location of this site in genome coordinates.</span>
<span class="sd">        Ranges from 0 (inclusive) to :attr:`TreeSequence.sequence_length`</span>
<span class="sd">        (exclusive).</span>
<span class="sd">    :vartype position: float</span>
<span class="sd">    :ivar ancestral_state: The ancestral state at this site (i.e., the state</span>
<span class="sd">        inherited by nodes, unless mutations occur).</span>
<span class="sd">    :vartype ancestral_state: str</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;` for this site.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    :ivar mutations: The list of mutations at this site. Mutations</span>
<span class="sd">        within a site are returned in the order they are specified in the</span>
<span class="sd">        underlying :class:`MutationTable`.</span>
<span class="sd">    :vartype mutations: list[:class:`Mutation`]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_</span><span class="p">,</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="n">ancestral_state</span><span class="p">,</span>
        <span class="n">mutations</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">ancestral_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span> <span class="o">=</span> <span class="n">mutations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span></div>


<div class="viewcode-block" id="Mutation"><a class="viewcode-back" href="../../python-api.html#tskit.Mutation">[docs]</a><span class="k">class</span> <span class="nc">Mutation</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`mutation &lt;sec_mutation_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar id: The integer ID of this mutation. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_mutations` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar site: The integer ID of the site that this mutation occurs at. To obtain</span>
<span class="sd">        further information about a site with a given ID use</span>
<span class="sd">        :meth:`TreeSequence.site`.</span>
<span class="sd">    :vartype site: int</span>
<span class="sd">    :ivar node: The integer ID of the first node that inherits this mutation.</span>
<span class="sd">        To obtain further information about a node with a given ID, use</span>
<span class="sd">        :meth:`TreeSequence.node`.</span>
<span class="sd">    :vartype node: int</span>
<span class="sd">    :ivar time: The occurrence time of this mutation.</span>
<span class="sd">    :vartype time: float</span>
<span class="sd">    :ivar derived_state: The derived state for this mutation. This is the state</span>
<span class="sd">        inherited by nodes in the subtree rooted at this mutation&#39;s node, unless</span>
<span class="sd">        another mutation occurs.</span>
<span class="sd">    :vartype derived_state: str</span>
<span class="sd">    :ivar parent: The integer ID of this mutation&#39;s parent mutation. When multiple</span>
<span class="sd">        mutations occur at a site along a path in the tree, mutations must</span>
<span class="sd">        record the mutation that is immediately above them. If the mutation does</span>
<span class="sd">        not have a parent, this is equal to the :data:`NULL` (-1).</span>
<span class="sd">        To obtain further information about a mutation with a given ID, use</span>
<span class="sd">        :meth:`TreeSequence.mutation`.</span>
<span class="sd">    :vartype parent: int</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;` for this</span>
<span class="sd">        mutation.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">site</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="n">UNKNOWN_TIME</span><span class="p">,</span>
        <span class="n">derived_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">=</span> <span class="n">site</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_state</span> <span class="o">=</span> <span class="n">derived_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># We need to remove metadata and the decoder so we are just comparing</span>
        <span class="c1"># the encoded metadata, along with the other attributes.</span>
        <span class="c1"># We also need to remove time as we have to compare to unknown time.</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">other_</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">other_</span><span class="p">[</span><span class="s2">&quot;_metadata_decoder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">other_</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">self_</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">self_</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">self_</span><span class="p">[</span><span class="s2">&quot;_metadata_decoder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">self_</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">self_</span> <span class="o">==</span> <span class="n">other_</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span>
            <span class="c1"># We need to special case unknown times as they are a nan value.</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Migration"><a class="viewcode-back" href="../../python-api.html#tskit.Migration">[docs]</a><span class="k">class</span> <span class="nc">Migration</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`migration &lt;sec_migration_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar left: The left end of the genomic interval covered by this</span>
<span class="sd">        migration (inclusive).</span>
<span class="sd">    :vartype left: float</span>
<span class="sd">    :ivar right: The right end of the genomic interval covered by this migration</span>
<span class="sd">        (exclusive).</span>
<span class="sd">    :vartype right: float</span>
<span class="sd">    :ivar node: The integer ID of the node involved in this migration event.</span>
<span class="sd">        To obtain further information about a node with a given ID, use</span>
<span class="sd">        :meth:`TreeSequence.node`.</span>
<span class="sd">    :vartype node: int</span>
<span class="sd">    :ivar source: The source population ID.</span>
<span class="sd">    :vartype source: int</span>
<span class="sd">    :ivar dest: The destination population ID.</span>
<span class="sd">    :vartype dest: int</span>
<span class="sd">    :ivar time: The time at which this migration occured at.</span>
<span class="sd">    :vartype time: float</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;` for this</span>
<span class="sd">        migration.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
        <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;{{left=</span><span class="si">{:.3f}</span><span class="s2">, right=</span><span class="si">{:.3f}</span><span class="s2">, node=</span><span class="si">{}</span><span class="s2">, source=</span><span class="si">{}</span><span class="s2">, dest=</span><span class="si">{}</span><span class="s2"> time=</span><span class="si">{:.3f}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; id=</span><span class="si">{}</span><span class="s2">, metadata=</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Population"><a class="viewcode-back" href="../../python-api.html#tskit.Population">[docs]</a><span class="k">class</span> <span class="nc">Population</span><span class="p">(</span><span class="n">SimpleContainerWithMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`population &lt;sec_population_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar id: The integer ID of this population. Varies from 0 to</span>
<span class="sd">        :attr:`TreeSequence.num_populations` - 1.</span>
<span class="sd">    :vartype id: int</span>
<span class="sd">    :ivar metadata: The decoded :ref:`metadata &lt;sec_metadata_definition&gt;`</span>
<span class="sd">        for this population.</span>
<span class="sd">    :vartype metadata: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">encoded_metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">metadata_decoder</span><span class="o">=</span><span class="k">lambda</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">metadata</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoded_metadata</span> <span class="o">=</span> <span class="n">encoded_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span></div>


<div class="viewcode-block" id="Variant"><a class="viewcode-back" href="../../python-api.html#tskit.Variant">[docs]</a><span class="k">class</span> <span class="nc">Variant</span><span class="p">(</span><span class="n">SimpleContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A variant represents the observed variation among samples</span>
<span class="sd">    for a given site. A variant consists (a) of a reference to the</span>
<span class="sd">    :class:`Site` instance in question; (b) the **alleles** that may be</span>
<span class="sd">    observed at the samples for this site; and (c) the **genotypes**</span>
<span class="sd">    mapping sample IDs to the observed alleles.</span>

<span class="sd">    Each element in the ``alleles`` tuple is a string, representing the</span>
<span class="sd">    actual observed state for a given sample. The ``alleles`` tuple is</span>
<span class="sd">    generated in one of two ways. The first (and default) way is for</span>
<span class="sd">    ``tskit`` to generate the encoding on the fly as alleles are encountered</span>
<span class="sd">    while generating genotypes. In this case, the first element of this</span>
<span class="sd">    tuple is guaranteed to be the same as the site&#39;s ``ancestral_state`` value</span>
<span class="sd">    and the list of alleles is also guaranteed not to contain any duplicates.</span>
<span class="sd">    Note that allelic values may be listed that are not referred to by any</span>
<span class="sd">    samples. For example, if we have a site that is fixed for the derived state</span>
<span class="sd">    (i.e., we have a mutation over the tree root), all genotypes will be 1, but</span>
<span class="sd">    the alleles list will be equal to ``(&#39;0&#39;, &#39;1&#39;)``. Other than the</span>
<span class="sd">    ancestral state being the first allele, the alleles are listed in</span>
<span class="sd">    no particular order, and the ordering should not be relied upon</span>
<span class="sd">    (but see the notes on missing data below).</span>

<span class="sd">    The second way is for the user to define the mapping between</span>
<span class="sd">    genotype values and allelic state strings using the</span>
<span class="sd">    ``alleles`` parameter to the :meth:`TreeSequence.variants` method.</span>
<span class="sd">    In this case, there is no indication of which allele is the ancestral state,</span>
<span class="sd">    as the ordering is determined by the user.</span>

<span class="sd">    The ``genotypes`` represent the observed allelic states for each sample,</span>
<span class="sd">    such that ``var.alleles[var.genotypes[j]]`` gives the string allele</span>
<span class="sd">    for sample ID ``j``. Thus, the elements of the genotypes array are</span>
<span class="sd">    indexes into the ``alleles`` list. The genotypes are provided in this</span>
<span class="sd">    way via a numpy array to enable efficient calculations.</span>

<span class="sd">    When :ref:`missing data&lt;sec_data_model_missing_data&gt;` is present at a given</span>
<span class="sd">    site boolean flag ``has_missing_data`` will be True, at least one element</span>
<span class="sd">    of the ``genotypes`` array will be equal to ``tskit.MISSING_DATA``, and the</span>
<span class="sd">    last element of the ``alleles`` array will be ``None``. Note that in this</span>
<span class="sd">    case ``variant.num_alleles`` will **not** be equal to</span>
<span class="sd">    ``len(variant.alleles)``. The rationale for adding ``None`` to the end of</span>
<span class="sd">    the ``alleles`` list is to help code that does not handle missing data</span>
<span class="sd">    correctly fail early rather than introducing subtle and hard-to-find bugs.</span>
<span class="sd">    As ``tskit.MISSING_DATA`` is equal to -1, code that decodes genotypes into</span>
<span class="sd">    allelic values without taking missing data into account would otherwise</span>
<span class="sd">    output the last allele in the list rather missing data.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>

<span class="sd">    :ivar site: The site object for this variant.</span>
<span class="sd">    :vartype site: :class:`Site`</span>
<span class="sd">    :ivar alleles: A tuple of the allelic values that may be observed at the</span>
<span class="sd">        samples at the current site. The first element of this tuple is always</span>
<span class="sd">        the site&#39;s ancestral state.</span>
<span class="sd">    :vartype alleles: tuple(str)</span>
<span class="sd">    :ivar genotypes: An array of indexes into the list ``alleles``, giving the</span>
<span class="sd">        state of each sample at the current site.</span>
<span class="sd">    :ivar has_missing_data: True if there is missing data for any of the</span>
<span class="sd">        samples at the current site.</span>
<span class="sd">    :vartype has_missing_data: bool</span>
<span class="sd">    :ivar num_alleles: The number of distinct alleles at this site. Note that</span>
<span class="sd">        this may be greater than the number of distinct values in the genotypes</span>
<span class="sd">        array.</span>
<span class="sd">    :vartype num_alleles: int</span>
<span class="sd">    :vartype genotypes: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">=</span> <span class="n">site</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span> <span class="o">=</span> <span class="n">alleles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_data</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_alleles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="n">genotypes</span>
        <span class="c1"># Deprecated aliases to avoid breaking existing code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">id</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">site</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">alleles</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
        <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Edgeset</span><span class="p">(</span><span class="n">SimpleContainer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{{left=</span><span class="si">{:.3f}</span><span class="s2">, right=</span><span class="si">{:.3f}</span><span class="s2">, parent=</span><span class="si">{}</span><span class="s2">, children=</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>


<div class="viewcode-block" id="Provenance"><a class="viewcode-back" href="../../python-api.html#tskit.Provenance">[docs]</a><span class="k">class</span> <span class="nc">Provenance</span><span class="p">(</span><span class="n">SimpleContainer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span> <span class="o">=</span> <span class="n">record</span></div>


<span class="k">def</span> <span class="nf">add_deprecated_mutation_attrs</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">mutation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add in attributes for the older deprecated way of defining</span>
<span class="sd">    mutations. These attributes will be removed in future releases</span>
<span class="sd">    and are deliberately undocumented in tskit v0.2.2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mutation</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span>
    <span class="n">mutation</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">id</span>
    <span class="k">return</span> <span class="n">mutation</span>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../python-api.html#tskit.Tree">[docs]</a><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single tree in a :class:`TreeSequence`. Please see the</span>
<span class="sd">    :ref:`sec_tutorial_moving_along_a_tree_sequence` section for information</span>
<span class="sd">    on how efficiently access trees sequentially or obtain a list</span>
<span class="sd">    of individual trees in a tree sequence.</span>

<span class="sd">    The ``sample_lists`` parameter controls the features that are enabled</span>
<span class="sd">    for this tree. If ``sample_lists`` is True a more efficient algorithm is</span>
<span class="sd">    used in the :meth:`Tree.samples` method.</span>

<span class="sd">    The ``tracked_samples`` parameter can be used to efficiently count the</span>
<span class="sd">    number of samples in a given set that exist in a particular subtree</span>
<span class="sd">    using the :meth:`Tree.num_tracked_samples` method.</span>

<span class="sd">    The :class:`Tree` class is a state-machine which has a state</span>
<span class="sd">    corresponding to each of the trees in the parent tree sequence. We</span>
<span class="sd">    transition between these states by using the seek functions like</span>
<span class="sd">    :meth:`Tree.first`, :meth:`Tree.last`, :meth:`Tree.seek` and</span>
<span class="sd">    :meth:`Tree.seek_index`. There is one more state, the so-called &quot;null&quot;</span>
<span class="sd">    or &quot;cleared&quot; state. This is the state that a :class:`Tree` is in</span>
<span class="sd">    immediately after initialisation;  it has an index of -1, and no edges. We</span>
<span class="sd">    can also enter the null state by calling :meth:`Tree.next` on the last</span>
<span class="sd">    tree in a sequence, calling :meth:`Tree.prev` on the first tree in a</span>
<span class="sd">    sequence or calling calling the :meth:`Tree.clear` method at any time.</span>

<span class="sd">    The high-level TreeSequence seeking and iterations methods (e.g,</span>
<span class="sd">    :meth:`TreeSequence.trees`) are built on these low-level state-machine</span>
<span class="sd">    seek operations. We recommend these higher level operations for most</span>
<span class="sd">    users.</span>

<span class="sd">    :param TreeSequence tree_sequence: The parent tree sequence.</span>
<span class="sd">    :param list tracked_samples: The list of samples to be tracked and</span>
<span class="sd">        counted using the :meth:`Tree.num_tracked_samples` method.</span>
<span class="sd">    :param bool sample_lists: If True, provide more efficient access</span>
<span class="sd">        to the samples beneath a give node using the</span>
<span class="sd">        :meth:`Tree.samples` method.</span>
<span class="sd">    :param int root_threshold: The minimum number of samples that a node</span>
<span class="sd">        must be ancestral to for it to be in the list of roots. By default</span>
<span class="sd">        this is 1, so that isolated samples (representing missing data)</span>
<span class="sd">        are roots. To efficiently restrict the roots of the tree to</span>
<span class="sd">        those subtending meaningful topology, set this to 2. This value</span>
<span class="sd">        is only relevant when trees have multiple roots.</span>
<span class="sd">    :param bool sample_counts: Deprecated since 0.2.4.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tree_sequence</span><span class="p">,</span>
        <span class="n">tracked_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_lists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">root_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">sample_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">options</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sample_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The sample_counts option is not supported since 0.2.4 &quot;</span>
                <span class="s2">&quot;and is ignored&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_lists</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">|=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">SAMPLE_LISTS</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">options</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">tracked_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO remove this when we allow numpy arrays in the low-level API.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tracked_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tracked_samples</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span> <span class="o">=</span> <span class="n">tree_sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">set_root_threshold</span><span class="p">(</span><span class="n">root_threshold</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.copy"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this tree. The returned tree will have identical state</span>
<span class="sd">        to this tree.</span>

<span class="sd">        :return: A copy of this tree.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">_tree_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">_ll_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">copy</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree sequence that this tree is from.</span>

<span class="sd">        :return: The parent tree sequence for this tree.</span>
<span class="sd">        :rtype: :class:`TreeSequence`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum number of samples that a node must be an ancestor</span>
<span class="sd">        of to be considered a potential root.</span>

<span class="sd">        :return: The root threshold.</span>
<span class="sd">        :rtype: :class:`TreeSequence`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_root_threshold</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.first"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the first tree in the sequence. This can be called whether</span>
<span class="sd">        the tree is in the null state or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.last"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the last tree in the sequence. This can be called whether</span>
<span class="sd">        the tree is in the null state or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">last</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.next"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa A002</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the next tree in the sequence. If the tree is in the initial</span>
<span class="sd">        null state we seek to the first tree (equivalent to calling :meth:`.first`).</span>
<span class="sd">        Calling ``next`` on the last tree in the sequence results in the tree</span>
<span class="sd">        being cleared back into the null initial state (equivalent to calling</span>
<span class="sd">        :meth:`clear`). The return value of the function indicates whether the</span>
<span class="sd">        tree is in a non-null state, and can be used to loop over the trees::</span>

<span class="sd">            # Iterate over the trees from left-to-right</span>
<span class="sd">            tree = tskit.Tree(tree_sequence)</span>
<span class="sd">            while tree.next()</span>
<span class="sd">                # Do something with the tree.</span>
<span class="sd">                print(tree.index)</span>
<span class="sd">            # tree is now back in the null state.</span>

<span class="sd">        :return: True if the tree has been transformed into one of the trees</span>
<span class="sd">            in the sequence; False if the tree has been transformed into the</span>
<span class="sd">            null state.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">next</span><span class="p">())</span></div>

<div class="viewcode-block" id="Tree.prev"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.prev">[docs]</a>    <span class="k">def</span> <span class="nf">prev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the previous tree in the sequence. If the tree is in the initial</span>
<span class="sd">        null state we seek to the last tree (equivalent to calling :meth:`.last`).</span>
<span class="sd">        Calling ``prev`` on the first tree in the sequence results in the tree</span>
<span class="sd">        being cleared back into the null initial state (equivalent to calling</span>
<span class="sd">        :meth:`clear`). The return value of the function indicates whether the</span>
<span class="sd">        tree is in a non-null state, and can be used to loop over the trees::</span>

<span class="sd">            # Iterate over the trees from right-to-left</span>
<span class="sd">            tree = tskit.Tree(tree_sequence)</span>
<span class="sd">            while tree.prev()</span>
<span class="sd">                # Do something with the tree.</span>
<span class="sd">                print(tree.index)</span>
<span class="sd">            # tree is now back in the null state.</span>

<span class="sd">        :return: True if the tree has been transformed into one of the trees</span>
<span class="sd">            in the sequence; False if the tree has been transformed into the</span>
<span class="sd">            null state.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">prev</span><span class="p">())</span></div>

<div class="viewcode-block" id="Tree.clear"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets this tree back to the initial null state. Calling this method</span>
<span class="sd">        on a tree already in the null state has no effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.seek_index"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.seek_index">[docs]</a>    <span class="k">def</span> <span class="nf">seek_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state to represent the tree at the specified</span>
<span class="sd">        index in the parent tree sequence. Negative indexes following the</span>
<span class="sd">        standard Python conventions are allowed, i.e., ``index=-1`` will</span>
<span class="sd">        seek to the last tree in the sequence.</span>

<span class="sd">        :param int index: The tree index to seek to.</span>
<span class="sd">        :raises IndexError: If an index outside the acceptable range is provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_trees</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">num_trees</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">num_trees</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="c1"># This should be implemented in C efficiently using the indexes.</span>
        <span class="c1"># No point in complicating the current implementation by trying</span>
        <span class="c1"># to seek from the correct direction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.seek"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.seek">[docs]</a>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state to represent the tree that covers the specified</span>
<span class="sd">        position in the parent tree sequence. After a successful return</span>
<span class="sd">        of this method we have ``tree.interval.left`` &lt;= ``position``</span>
<span class="sd">        &lt; ``tree.interval.right``.</span>

<span class="sd">        :param float position: The position along the sequence length to</span>
<span class="sd">            seek to.</span>
<span class="sd">        :raises ValueError: If 0 &lt; position or position &gt;=</span>
<span class="sd">            :attr:`TreeSequence.sequence_length`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">position</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position out of bounds&quot;</span><span class="p">)</span>
        <span class="c1"># This should be implemented in C efficiently using the indexes.</span>
        <span class="c1"># No point in complicating the current implementation by trying</span>
        <span class="c1"># to seek from the correct direction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">position</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.rank"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.rank">[docs]</a>    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce the rank of this tree in the enumeration of all leaf-labelled</span>
<span class="sd">        trees of n leaves. See the :ref:`sec_tree_ranks` section for</span>
<span class="sd">        details on ranking and unranking trees.</span>

<span class="sd">        :rtype: tuple(int)</span>
<span class="sd">        :raises ValueError: If the tree has multiple roots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">RankTree</span><span class="o">.</span><span class="n">from_tsk_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span></div>

<div class="viewcode-block" id="Tree.unrank"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.unrank">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unrank</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the tree of the given ``rank``</span>
<span class="sd">        (see :meth:`tskit.Tree.rank`) with ``num_leaves`` leaves.</span>
<span class="sd">        The labels and times of internal nodes are assigned by a postorder</span>
<span class="sd">        traversal of the nodes, such that the time of each internal node</span>
<span class="sd">        is the maximum time of its children plus the specified ``branch_length``.</span>
<span class="sd">        The time of each leaf is 0.</span>

<span class="sd">        See the :ref:`sec_tree_ranks` section for details on ranking and</span>
<span class="sd">        unranking trees and what constitutes valid ranks.</span>

<span class="sd">        :param int num_leaves: The number of leaves of the tree to generate.</span>
<span class="sd">        :param tuple(int) rank: The rank of the tree to generate.</span>
<span class="sd">        :param float span: The genomic span of the returned tree. The tree will cover</span>
<span class="sd">            the interval :math:`[0, \\text{span})` and the :attr:`~Tree.tree_sequence`</span>
<span class="sd">            from which the tree is taken will have its</span>
<span class="sd">            :attr:`~tskit.TreeSequence.sequence_length` equal to ``span``.</span>
<span class="sd">        :param: float branch_length: The minimum length of a branch in this tree.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        :raises: ValueError: If the given rank is out of bounds for trees</span>
<span class="sd">            with ``num_leaves`` leaves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank_tree</span> <span class="o">=</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">RankTree</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rank_tree</span><span class="o">.</span><span class="n">to_tsk_tree</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.count_topologies"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.count_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the distribution of embedded topologies for every combination</span>
<span class="sd">        of the sample sets in ``sample_sets``. ``sample_sets`` defaults to all</span>
<span class="sd">        samples in the tree grouped by population.</span>

<span class="sd">        ``sample_sets`` need not include all samples but must be pairwise disjoint.</span>

<span class="sd">        The returned object is a :class:`tskit.TopologyCounter` that contains</span>
<span class="sd">        counts of topologies per combination of sample sets. For example,</span>

<span class="sd">        &gt;&gt;&gt; topology_counter = tree.count_topologies()</span>
<span class="sd">        &gt;&gt;&gt; rank, count = topology_counter[0, 1, 2].most_common(1)[0]</span>

<span class="sd">        produces the most common tree topology, with populations 0, 1</span>
<span class="sd">        and 2 as its tips, according to the genealogies of those</span>
<span class="sd">        populations&#39; samples in this tree.</span>

<span class="sd">        The counts for each topology in the :class:`tskit.TopologyCounter`</span>
<span class="sd">        are absolute counts that we would get if we were to select all</span>
<span class="sd">        combinations of samples from the relevant sample sets.</span>
<span class="sd">        For sample sets :math:`[s_0, s_1, ..., s_n]`, the total number of</span>
<span class="sd">        topologies for those sample sets is equal to</span>
<span class="sd">        :math:`|s_0| * |s_1| * ... * |s_n|`, so the counts in the counter</span>
<span class="sd">        ``topology_counter[0, 1, ..., n]`` should sum to</span>
<span class="sd">        :math:`|s_0| * |s_1| * ... * |s_n|`.</span>

<span class="sd">        To convert the topology counts to probabilities, divide by the total</span>
<span class="sd">        possible number of sample combinations from the sample sets in question::</span>

<span class="sd">            &gt;&gt;&gt; set_sizes = [len(sample_set) for sample_set in sample_sets]</span>
<span class="sd">            &gt;&gt;&gt; p = count / (set_sizes[0] * set_sizes[1] * set_sizes[2])</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">            Defaults to all samples grouped by population.</span>
<span class="sd">        :rtype: tskit.TopologyCounter</span>
<span class="sd">        :raises ValueError: If nodes in ``sample_sets`` are invalid or are</span>
<span class="sd">            internal samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">populations</span><span class="p">()</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">tree_count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for branch_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.branch_length"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.branch_length">[docs]</a>    <span class="k">def</span> <span class="nf">branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the branch (in generations) joining the</span>
<span class="sd">        specified node to its parent. This is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; tree.time(tree.parent(u)) - tree.time(u)</span>

<span class="sd">        The branch length for a node that has no parent (e.g., a root) is</span>
<span class="sd">        defined as zero.</span>

<span class="sd">        Note that this is not related to the property `.length` which</span>
<span class="sd">        is a deprecated alias for the genomic :attr:`~Tree.span` covered by a tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The branch length from u to its parent.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">get_total_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for total_branch_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_branch_length</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sum of all the branch lengths in this tree (in</span>
<span class="sd">        units of generations). This is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; sum(tree.branch_length(u) for u in tree.nodes())</span>

<span class="sd">        Note that the branch lengths for root nodes are defined as zero.</span>

<span class="sd">        As this is defined by a traversal of the tree, technically we</span>
<span class="sd">        return the sum of all branch lengths that are reachable from</span>
<span class="sd">        roots. Thus, this is the sum of all branches that are ancestral</span>
<span class="sd">        to at least one sample. This distinction is only important</span>
<span class="sd">        in tree sequences that contain &#39;dead branches&#39;, i.e., those</span>
<span class="sd">        that define topology not ancestral to any samples.</span>

<span class="sd">        :return: The sum of lengths of branches in this tree.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_mrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for mrca</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.mrca"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.mrca">[docs]</a>    <span class="k">def</span> <span class="nf">mrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the most recent common ancestor of the specified nodes.</span>

<span class="sd">        :param int u: The first node.</span>
<span class="sd">        :param int v: The second node.</span>
<span class="sd">        :return: The most recent common ancestor of u and v.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_tmrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for tmrca</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.tmrca"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.tmrca">[docs]</a>    <span class="k">def</span> <span class="nf">tmrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time of the most recent common ancestor of the specified</span>
<span class="sd">        nodes. This is equivalent to::</span>

<span class="sd">        &gt;&gt;&gt; tree.time(tree.mrca(u, v))</span>

<span class="sd">        :param int u: The first node.</span>
<span class="sd">        :param int v: The second node.</span>
<span class="sd">        :return: The time of the most recent common ancestor of u and v.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">get_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for parent</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.parent"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parent of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a root or is not a node in</span>
<span class="sd">        the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The parent of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="c1"># Quintuply linked tree structure.</span>

<div class="viewcode-block" id="Tree.left_child"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.left_child">[docs]</a>    <span class="k">def</span> <span class="nf">left_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leftmost child of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a leaf or is not a node in</span>
<span class="sd">        the current tree. The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :meth:`.children` method is a more</span>
<span class="sd">        convenient way to obtain the children of a given node.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The leftmost child of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_child</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.right_child"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.right_child">[docs]</a>    <span class="k">def</span> <span class="nf">right_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the rightmost child of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a leaf or is not a node in</span>
<span class="sd">        the current tree. The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :meth:`.children` method is a more</span>
<span class="sd">        convenient way to obtain the children of a given node.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The rightmost child of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_child</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.left_sib"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.left_sib">[docs]</a>    <span class="k">def</span> <span class="nf">left_sib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sibling node to the left of u, or :data:`tskit.NULL`</span>
<span class="sd">        if u does not have a left sibling.</span>
<span class="sd">        The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The sibling node to the left of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.right_sib"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.right_sib">[docs]</a>    <span class="k">def</span> <span class="nf">right_sib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sibling node to the right of u, or :data:`tskit.NULL`</span>
<span class="sd">        if u does not have a right sibling.</span>
<span class="sd">        The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The sibling node to the right of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="c1"># Sample list.</span>

    <span class="k">def</span> <span class="nf">left_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">right_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_next_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="c1"># TODO do we also have right_root?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The leftmost root in this tree. If there are multiple roots</span>
<span class="sd">        in this tree, they are siblings of this node, and so we can</span>
<span class="sd">        use :meth:`.right_sib` to iterate over all roots:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            u = tree.left_root</span>
<span class="sd">            while u != tskit.NULL:</span>
<span class="sd">                print(&quot;Root:&quot;, u)</span>
<span class="sd">                u = tree.right_sib(u)</span>

<span class="sd">        The left-to-right ordering of roots is arbitrary and should</span>
<span class="sd">        not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;`</span>
<span class="sd">        section for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :attr:`~Tree.roots` attribute is a more</span>
<span class="sd">        convenient way to obtain the roots of a tree. If you are assuming</span>
<span class="sd">        that there is a single root in the tree you should use the</span>
<span class="sd">        :attr:`~Tree.root` property.</span>

<span class="sd">        .. warning:: Do not use this property if you are assuming that there</span>
<span class="sd">            is a single root in trees that are being processed. The</span>
<span class="sd">            :attr:`~Tree.root` property should be used in this case, as it will</span>
<span class="sd">            raise an error when multiple roots exists.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_root</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.children</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.children"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the children of the specified node ``u`` as a tuple of integer node IDs.</span>
<span class="sd">        If ``u`` is a leaf, return the empty tuple. The ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The children of ``u`` as a tuple of integers</span>
<span class="sd">        :rtype: tuple(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.time</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.time"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.time">[docs]</a>    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time of the specified node in generations.</span>
<span class="sd">        Equivalent to ``tree.tree_sequence.node(u).time``.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The time of u.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.depth"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of nodes on the path from ``u`` to a</span>
<span class="sd">        root, not including ``u``. Thus, the depth of a root is</span>
<span class="sd">        zero.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The depth of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.population</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.population"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.population">[docs]</a>    <span class="k">def</span> <span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the population associated with the specified node.</span>
<span class="sd">        Equivalent to ``tree.tree_sequence.node(u).population``.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The ID of the population associated with node u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_population</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.is_internal"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_internal">[docs]</a>    <span class="k">def</span> <span class="nf">is_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is not a leaf. A node is internal</span>
<span class="sd">        if it has one or more children in the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is not a leaf node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.is_leaf"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is a leaf. A node :math:`u` is a</span>
<span class="sd">        leaf if it has zero children.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is a leaf node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Tree.is_isolated"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_isolated">[docs]</a>    <span class="k">def</span> <span class="nf">is_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is isolated in this tree: that is</span>
<span class="sd">        it has no parents and no children. Sample nodes that are isolated</span>
<span class="sd">        and have no mutations above them are used to represent</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is an isolated node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">NULL</span></div>

<div class="viewcode-block" id="Tree.is_sample"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_sample">[docs]</a>    <span class="k">def</span> <span class="nf">is_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is a sample. A node :math:`u` is a</span>
<span class="sd">        sample if it has been marked as a sample in the parent tree sequence.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is a sample.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(</span><span class="n">u</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tree.is_descendant"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_descendant">[docs]</a>    <span class="k">def</span> <span class="nf">is_descendant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node u is a descendant of node v and False</span>
<span class="sd">        otherwise. A node :math:`u` is a descendant of another node :math:`v` if</span>
<span class="sd">        :math:`v` is on the path from :math:`u` to root. A node is considered</span>
<span class="sd">        to be a descendant of itself, so ``tree.is_descendant(u, u)`` will be</span>
<span class="sd">        True for any valid node.</span>

<span class="sd">        :param int u: The descendant node.</span>
<span class="sd">        :param int v: The ancestral node.</span>
<span class="sd">        :return: True if u is a descendant of v.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises ValueError: If u or v are not valid node IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">is_descendant</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of nodes in the :class:`TreeSequence` this tree is in.</span>
<span class="sd">        Equivalent to ``tree.tree_sequence.num_nodes``. To find the number of</span>
<span class="sd">        nodes that are reachable from all roots use ``len(list(tree.nodes()))``.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of roots in this tree, as defined in the :attr:`~Tree.roots`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Requires O(number of roots) time.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_roots</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of roots in this tree. A root is defined as a unique endpoint of</span>
<span class="sd">        the paths starting at samples. We can define the set of roots as follows:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            roots = set()</span>
<span class="sd">            for u in tree_sequence.samples():</span>
<span class="sd">                while tree.parent(u) != tskit.NULL:</span>
<span class="sd">                    u = tree.parent(u)</span>
<span class="sd">                roots.add(u)</span>
<span class="sd">            # roots is now the set of all roots in this tree.</span>
<span class="sd">            assert sorted(roots) == sorted(tree.roots)</span>

<span class="sd">        The roots of the tree are returned in a list, in no particular order.</span>

<span class="sd">        Requires O(number of roots) time.</span>

<span class="sd">        :return: The list of roots in this tree.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>
        <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">roots</span>

    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.root</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The root of this tree. If the tree contains multiple roots, a ValueError is</span>
<span class="sd">        raised indicating that the :attr:`~Tree.roots` attribute should be used instead.</span>

<span class="sd">        :return: The root node.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises: :class:`ValueError` if this tree contains more than one root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sib</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;More than one root exists. Use tree.roots instead&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index this tree occupies in the parent tree sequence.</span>
<span class="sd">        This index is zero based, so the first tree in the sequence has index 0.</span>

<span class="sd">        :return: The index of this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_index</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.interval</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the genomic interval that this tree</span>
<span class="sd">        represents the history of. The interval is returned as a tuple</span>
<span class="sd">        :math:`(l, r)` and is a half-open interval such that the left</span>
<span class="sd">        coordinate is inclusive and the right coordinate is exclusive. This</span>
<span class="sd">        tree therefore applies to all genomic locations :math:`x` such that</span>
<span class="sd">        :math:`l \\leq x &lt; r`.</span>

<span class="sd">        :return: A named tuple (l, r) representing the left-most (inclusive)</span>
<span class="sd">            and right-most (exclusive) coordinates of the genomic region</span>
<span class="sd">            covered by this tree. The coordinates can be accessed by index</span>
<span class="sd">            (``0`` or ``1``) or equivalently by name (``.left`` or ``.right``)</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.span</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.span</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the genomic distance that this tree spans.</span>
<span class="sd">        This is defined as :math:`r - l`, where :math:`(l, r)` is the genomic</span>
<span class="sd">        interval returned by :attr:`~Tree.interval`.</span>

<span class="sd">        :return: The genomic distance covered by this tree.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interval</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>

    <span class="c1"># The sample_size (or num_samples) is really a property of the tree sequence,</span>
    <span class="c1"># and so we should provide access to this via a tree.tree_sequence.num_samples</span>
    <span class="c1"># property access. However, we can&#39;t just remove the method as a lot of code</span>
    <span class="c1"># may depend on it. To complicate things a bit more, sample_size has been</span>
    <span class="c1"># changed to num_samples elsewhere for consistency. We can&#39;t do this here</span>
    <span class="c1"># because there is already a num_samples method which returns the number of</span>
    <span class="c1"># samples below a particular node. The best thing to do is probably to</span>
    <span class="c1"># undocument the sample_size property, but keep it around for ever.</span>

    <span class="k">def</span> <span class="nf">get_sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.sample_size</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sample size for this tree. This is the number of sample</span>
<span class="sd">        nodes in the tree.</span>

<span class="sd">        :return: The number of sample nodes in the tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_sample_size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">check_orientation</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">in</span> <span class="p">(</span><span class="n">drawing</span><span class="o">.</span><span class="n">LEFT</span><span class="p">,</span> <span class="n">drawing</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">):</span>
            <span class="n">text_tree</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">HorizontalTextTree</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text_tree</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">VerticalTextTree</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">text_tree</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.draw_svg"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.draw_svg">[docs]</a>    <span class="k">def</span> <span class="nf">draw_svg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tree_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">root_svg_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_root_branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an SVG representation of a single tree.</span>

<span class="sd">        When working in a Jupyter notebook, use the ``IPython.display.SVG`` function</span>
<span class="sd">        to display the SVG output from this function inline in the notebook::</span>

<span class="sd">            &gt;&gt;&gt; SVG(tree.draw_svg())</span>

<span class="sd">        The elements in the tree are grouped according to the structure of the tree,</span>
<span class="sd">        using `SVG groups &lt;https://www.w3.org/TR/SVG2/struct.html#Groups&gt;`_. This allows</span>
<span class="sd">        easy styling and manipulation of elements and subtrees. Elements in the SVG file</span>
<span class="sd">        are marked with SVG classes so that they can be targetted, allowing</span>
<span class="sd">        different components of the drawing to be hidden, styled, or otherwise</span>
<span class="sd">        manipulated. For example, when drawing (say) the first tree from a tree</span>
<span class="sd">        sequence, all the SVG components will be placed in a group of class ``tree``.</span>
<span class="sd">        The group will have the additional class ``t0``, indicating that this tree</span>
<span class="sd">        has index 0 in the tree sequence. The general SVG structure is as follows:</span>

<span class="sd">        The tree is contained in a group of class ``tree``. Additionally, this group</span>
<span class="sd">        has a class ``tN`` where `N` is the tree index.</span>

<span class="sd">        Within the ``tree`` group there is a nested hierarchy of groups corresponding</span>
<span class="sd">        to the tree structure. Any particular node in the tree will have a corresponding</span>
<span class="sd">        group containing child groups (if any) followed by the edge above that node, a</span>
<span class="sd">        node symbol, and (potentially) text containing the node label. For example, a</span>
<span class="sd">        simple two tip tree, with tip node ids 0 and 1, and a root node id of 2 will have</span>
<span class="sd">        a structure similar to the following:</span>

<span class="sd">        .. code-block::</span>

<span class="sd">            &lt;g class=&quot;tree t0&quot;&gt;</span>
<span class="sd">              &lt;g class=&quot;node n2 root&quot;&gt;</span>
<span class="sd">                &lt;g class=&quot;node n1 a2 i1 p1 sample leaf&quot;&gt;</span>
<span class="sd">                  &lt;path class=&quot;edge&quot; ... /&gt;</span>
<span class="sd">                  &lt;circle class=&quot;sym&quot; ... /&gt;</span>
<span class="sd">                  &lt;text class=&quot;lab&quot; ...&gt;Node 1&lt;/text&gt;</span>
<span class="sd">                &lt;/g&gt;</span>
<span class="sd">                &lt;g class=&quot;node n0 a2 i2 p1 sample leaf&quot;&gt;</span>
<span class="sd">                  &lt;path class=&quot;edge&quot; ... /&gt;</span>
<span class="sd">                  &lt;circle class=&quot;sym&quot; .../&gt;</span>
<span class="sd">                  &lt;text class=&quot;lab&quot; ...&gt;Node 0&lt;/text&gt;</span>
<span class="sd">                &lt;/g&gt;</span>
<span class="sd">                &lt;path class=&quot;edge&quot; ... /&gt;</span>
<span class="sd">                &lt;circle /&gt;</span>
<span class="sd">                &lt;text class=&quot;lab&quot;&gt;Root (Node 2)&lt;/text&gt;</span>
<span class="sd">              &lt;/g&gt;</span>
<span class="sd">            &lt;/g&gt;</span>

<span class="sd">        The classes can be used to manipulate the element, e.g. by using</span>
<span class="sd">        `stylesheets &lt;https://www.w3.org/TR/SVG2/styling.html&gt;`_. Style strings can</span>
<span class="sd">        be embedded in the svg by using the ``style`` parameter, or added to html</span>
<span class="sd">        pages which contain the raw SVG (e.g. within a Jupyter notebook by using the</span>
<span class="sd">        IPython ``HTML()`` function). As a simple example, passing the following</span>
<span class="sd">        string as the ``style`` parameter will hide all labels:</span>

<span class="sd">        .. code-block:: css</span>

<span class="sd">            .tree .lab {visibility: hidden}</span>

<span class="sd">        You can also change the format of various items: in SVG2-compatible viewers,</span>
<span class="sd">        the following styles will rotate the leaf nodes labels by 90 degrees, colour</span>
<span class="sd">        the leaf node symbols blue, and</span>
<span class="sd">        hide the non-sample node labels. Note that SVG1.1 does not recognize the</span>
<span class="sd">        ``transform`` style, so in some SVG viewers, the labels will not appear rotated:</span>
<span class="sd">        a workaround is to convert the SVG to PDF first, using e.g. the programmable</span>
<span class="sd">        chromium engine: ``chromium --headless --print-to-pdf=out.pdf in.svg``)</span>

<span class="sd">        .. code-block:: css</span>

<span class="sd">            .tree .node.leaf &gt; .lab {</span>
<span class="sd">                transform: translateY(0.5em) rotate(90deg); text-anchor: start}</span>
<span class="sd">            .tree .node.leaf &gt; .sym {fill: blue}</span>
<span class="sd">            .tree .node:not(.sample) &gt; .lab {visibility: hidden}</span>

<span class="sd">        Nodes contain classes that allow them to be targetted by node id (``nX``),</span>
<span class="sd">        ancestor (parent) id (``aX`` or ``root`` if this node has no parent), and</span>
<span class="sd">        (if defined) the id of the individual (``iX``) and population (``pX``) to</span>
<span class="sd">        which this node belongs. Hence the following style will display</span>
<span class="sd">        a large symbol for node 10, coloured red with a black border, and will also use</span>
<span class="sd">        thick red lines for all the edges that have it as a direct or indirect parent</span>
<span class="sd">        (note that, as with the ``transform`` style, changing the geometrical size of</span>
<span class="sd">        symbols is only possible in SVG2 and above and therefore not all SVG viewers</span>
<span class="sd">        will render such symbol size changes correctly).</span>

<span class="sd">        .. code-block:: css</span>

<span class="sd">            .tree .node.n10 &gt; .sym {fill: red; stroke: black; r: 8px}</span>
<span class="sd">            .tree .node.a10 .edge {stroke: red; stroke-width: 2px}</span>

<span class="sd">        .. note::</span>

<span class="sd">            A feature of SVG style commands is that they apply not just to the contents</span>
<span class="sd">            within the &lt;svg&gt; container, but to the entire file. Thus if an SVG file is</span>
<span class="sd">            embedded in a larger document, such as an HTML file (e.g. when an SVG</span>
<span class="sd">            is displayed inline in a Jupyter notebook), the style will apply to all SVG</span>
<span class="sd">            drawings in the notebook. To avoid this, you can tag the SVG with a unique</span>
<span class="sd">            SVG using ``root_svg_attributes={&#39;id&#39;:&#39;MY_UID&#39;}``, and prepend this to the</span>
<span class="sd">            style string, as in ``#MY_UID .tree .edges {stroke: gray}``.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not</span>
<span class="sd">            write to file.</span>
<span class="sd">        :param size: A tuple of (width, height) giving the width and height of the</span>
<span class="sd">            produced SVG drawing in abstract user units (usually interpreted as pixels on</span>
<span class="sd">            initial display).</span>
<span class="sd">        :type size: tuple(int, int)</span>
<span class="sd">        :param str tree_height_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;`` (the default), node heights are proportional</span>
<span class="sd">            to their time values. If this is equal to ``&quot;log_time&quot;``, node heights are</span>
<span class="sd">            proportional to their log(time) values. If it is equal to ``&quot;rank&quot;``, node</span>
<span class="sd">            heights are spaced equally according to their ranked times.</span>
<span class="sd">        :param str,float max_tree_height: The maximum tree height value in the current</span>
<span class="sd">            scaling system (see ``tree_height_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;`` (the default), the maximum tree height</span>
<span class="sd">            is set to be that of the oldest root in the tree. If equal to ``&quot;ts&quot;`` the</span>
<span class="sd">            maximum height is set to be the height of the oldest root in the tree</span>
<span class="sd">            sequence; this is useful when drawing trees from the same tree sequence as it</span>
<span class="sd">            ensures that node heights are consistent. If a numeric value, this is used as</span>
<span class="sd">            the maximum tree height by which to scale other nodes.</span>
<span class="sd">        :param node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            (specified by ID) that are present in this map; any nodes not present will</span>
<span class="sd">            not have a label.</span>
<span class="sd">        :type node_labels: dict(int, str)</span>
<span class="sd">        :param mutation_labels: If specified, show custom labels for the</span>
<span class="sd">            mutations (specified by ID) that are present in the map; any mutations</span>
<span class="sd">            not present will not have a label.</span>
<span class="sd">        :type mutation_labels: dict(int, str)</span>
<span class="sd">        :param dict root_svg_attributes: Additional attributes, such as an id, that will</span>
<span class="sd">            be embedded in the root ``&lt;svg&gt;`` tag of the generated drawing.</span>
<span class="sd">        :param str style: A</span>
<span class="sd">            `css style string &lt;https://www.w3.org/TR/CSS22/syndata.html&gt;`_ that will be</span>
<span class="sd">            included in the ``&lt;style&gt;`` tag of the generated svg. Note that certain</span>
<span class="sd">            styles, in particular transformations and changes in geometrical properties</span>
<span class="sd">            of objects, will only be recognised by SVG2-compatible viewers.</span>
<span class="sd">        :param str order: A string specifying the traversal type used to order the tips</span>
<span class="sd">            in the tree, as detailed in :meth:`Tree.nodes`. If None (default), use</span>
<span class="sd">            the default order as described in that method.</span>
<span class="sd">        :param bool force_root_branch: If ``True`` always plot a branch (edge) above the</span>
<span class="sd">            root(s) in the tree. If ``None`` (default) then only plot such root branches</span>
<span class="sd">            if there is a mutation above a root of the tree.</span>

<span class="sd">        :return: An SVG representation of a tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">SvgTree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">max_tree_height</span><span class="o">=</span><span class="n">max_tree_height</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">root_svg_attributes</span><span class="o">=</span><span class="n">root_svg_attributes</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">force_root_branch</span><span class="o">=</span><span class="n">force_root_branch</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">drawing</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: removed the pretty here when this is stable.</span>
            <span class="n">draw</span><span class="o">.</span><span class="n">drawing</span><span class="o">.</span><span class="n">saveas</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Tree.draw"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa A002</span>
        <span class="n">edge_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tree_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a drawing of this tree.</span>

<span class="sd">        When working in a Jupyter notebook, use the ``IPython.display.SVG``</span>
<span class="sd">        function to display the SVG output from this function inline in the notebook::</span>

<span class="sd">            &gt;&gt;&gt; SVG(tree.draw())</span>

<span class="sd">        The unicode format uses unicode `box drawing characters</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Box-drawing_character&gt;`_ to render the tree.</span>
<span class="sd">        This allows rendered trees to be printed out to the terminal::</span>

<span class="sd">            &gt;&gt;&gt; print(tree.draw(format=&quot;unicode&quot;))</span>
<span class="sd">              6</span>
<span class="sd">            </span>
<span class="sd">               5</span>
<span class="sd">             </span>
<span class="sd">               4</span>
<span class="sd">              </span>
<span class="sd">            3 0 1 2</span>

<span class="sd">        The ``node_labels`` argument allows the user to specify custom labels</span>
<span class="sd">        for nodes, or no labels at all::</span>

<span class="sd">            &gt;&gt;&gt; print(tree.draw(format=&quot;unicode&quot;, node_labels={}))</span>
<span class="sd">              </span>
<span class="sd">            </span>
<span class="sd">               </span>
<span class="sd">             </span>
<span class="sd">               </span>
<span class="sd">              </span>
<span class="sd">               </span>

<span class="sd">        Note: in some environments such as Jupyter notebooks with Windows or Mac,</span>
<span class="sd">        users have observed that the Unicode box drawings can be misaligned. In</span>
<span class="sd">        these cases, we recommend using the SVG or ASCII display formats instead.</span>
<span class="sd">        If you have a strong preference for aligned Unicode, you can try out the</span>
<span class="sd">        solution documented</span>
<span class="sd">        `here &lt;https://github.com/tskit-dev/tskit/issues/189#issuecomment-499114811&gt;`_.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not</span>
<span class="sd">            write to file.</span>
<span class="sd">        :param int width: The width of the image in pixels. If not specified, either</span>
<span class="sd">            defaults to the minimum size required to depict the tree (text formats)</span>
<span class="sd">            or 200 pixels.</span>
<span class="sd">        :param int height: The height of the image in pixels. If not specified, either</span>
<span class="sd">            defaults to the minimum size required to depict the tree (text formats)</span>
<span class="sd">            or 200 pixels.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param dict node_colours: If specified, show custom colours for the nodes</span>
<span class="sd">            given in the map. Any nodes not specified in the map will take the default</span>
<span class="sd">            colour; a value of ``None`` is treated as transparent and hence the node</span>
<span class="sd">            symbol is not plotted. (Only supported in the SVG format.)</span>
<span class="sd">        :param dict mutation_labels: If specified, show custom labels for the mutations</span>
<span class="sd">            (specified by ID) that are present in the map. Any mutations not in the map</span>
<span class="sd">            will not have a label. (Showing mutations is currently only supported in the</span>
<span class="sd">            SVG format)</span>
<span class="sd">        :param dict mutation_colours: If specified, show custom colours for the mutations</span>
<span class="sd">            given in the map (specified by ID). As for ``node_colours``, mutations not</span>
<span class="sd">            present in the map take the default colour, and those mapping to ``None``</span>
<span class="sd">            are not drawn. (Only supported in the SVG format.)</span>
<span class="sd">        :param str format: The format of the returned image. Currently supported</span>
<span class="sd">            are &#39;svg&#39;, &#39;ascii&#39; and &#39;unicode&#39;. Note that the :meth:`Tree.draw_svg`</span>
<span class="sd">            method provides more comprehensive functionality for creating SVGs.</span>
<span class="sd">        :param dict edge_colours: If specified, show custom colours for the edge</span>
<span class="sd">            joining each node in the map to its parent. As for ``node_colours``,</span>
<span class="sd">            unspecified edges take the default colour, and ``None`` values result in the</span>
<span class="sd">            edge being omitted. (Only supported in the SVG format.)</span>
<span class="sd">        :param str tree_height_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;``, node heights are proportional to their time</span>
<span class="sd">            values. If this is equal to ``&quot;log_time&quot;``, node heights are proportional to</span>
<span class="sd">            their log(time) values. If it is equal to ``&quot;rank&quot;``, node heights are spaced</span>
<span class="sd">            equally according to their ranked times. For SVG output the default is</span>
<span class="sd">            &#39;time&#39;-scale whereas for text output the default is &#39;rank&#39;-scale.</span>
<span class="sd">            Time scaling is not currently supported for text output.</span>
<span class="sd">        :param str,float max_tree_height: The maximum tree height value in the current</span>
<span class="sd">            scaling system (see ``tree_height_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;``, the maximum tree height is set to be</span>
<span class="sd">            that of the oldest root in the tree. If equal to ``&quot;ts&quot;`` the maximum</span>
<span class="sd">            height is set to be the height of the oldest root in the tree sequence;</span>
<span class="sd">            this is useful when drawing trees from the same tree sequence as it ensures</span>
<span class="sd">            that node heights are consistent. If a numeric value, this is used as the</span>
<span class="sd">            maximum tree height by which to scale other nodes. This parameter</span>
<span class="sd">            is not currently supported for text output.</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in the drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>
<span class="sd">        :return: A representation of this tree in the requested format.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">draw_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">node_colours</span><span class="o">=</span><span class="n">node_colours</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">mutation_colours</span><span class="o">=</span><span class="n">mutation_colours</span><span class="p">,</span>
            <span class="n">edge_colours</span><span class="o">=</span><span class="n">edge_colours</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">max_tree_height</span><span class="o">=</span><span class="n">max_tree_height</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="nf">get_num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of mutations across all sites on this tree.</span>

<span class="sd">        :return: The total number of mutations over all sites on this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sites on this tree.</span>

<span class="sd">        :return: The number of sites on this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.sites"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.sites">[docs]</a>    <span class="k">def</span> <span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the :ref:`sites &lt;sec_site_table_definition&gt;`</span>
<span class="sd">        in this tree. Sites are returned in order of increasing ID</span>
<span class="sd">        (and also position). See the :class:`Site` class for details on</span>
<span class="sd">        the available fields for each site.</span>

<span class="sd">        :return: An iterator over all sites in this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the low-level API to just return the IDs of the sites.</span>
        <span class="k">for</span> <span class="n">ll_site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_sites</span><span class="p">():</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ll_site</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">site</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.mutations"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.mutations">[docs]</a>    <span class="k">def</span> <span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the</span>
<span class="sd">        :ref:`mutations &lt;sec_mutation_table_definition&gt;` in this tree.</span>
<span class="sd">        Mutations are returned in their</span>
<span class="sd">        :ref:`order in the mutations table&lt;sec_mutation_requirements&gt;`,</span>
<span class="sd">        that is, by nondecreasing site ID, and within a site, by decreasing</span>
<span class="sd">        mutation time with parent mutations before their children.</span>
<span class="sd">        See the :class:`Mutation` class for details on the available fields for</span>
<span class="sd">        each mutation.</span>

<span class="sd">        The returned iterator is equivalent to iterating over all sites</span>
<span class="sd">        and all mutations in each site, i.e.::</span>

<span class="sd">            &gt;&gt;&gt; for site in tree.sites():</span>
<span class="sd">            &gt;&gt;&gt;     for mutation in site.mutations:</span>
<span class="sd">            &gt;&gt;&gt;         yield mutation</span>

<span class="sd">        :return: An iterator over all :class:`Mutation` objects in this tree.</span>
<span class="sd">        :rtype: iter(:class:`Mutation`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">add_deprecated_mutation_attrs</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">mutation</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for samples. See the discussion in the get_num_leaves</span>
        <span class="c1"># method for why this method is here and why it is semantically incorrect.</span>
        <span class="c1"># The &#39;leaves&#39; iterator below correctly returns the leaves below a given</span>
        <span class="c1"># node.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.leaves"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.leaves">[docs]</a>    <span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the leaves in this tree that are</span>
<span class="sd">        underneath the specified node. If u is not specified, return all leaves</span>
<span class="sd">        in the tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: An iterator over all leaves in the subtree rooted at u.</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">v</span></div>

    <span class="k">def</span> <span class="nf">_sample_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_options</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">SAMPLE_LISTS</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">samples</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_sample</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fall back on iterating over all nodes in the tree, yielding</span>
            <span class="c1"># samples as we see them.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">v</span>

<div class="viewcode-block" id="Tree.samples"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.samples">[docs]</a>    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the samples in this tree that are</span>
<span class="sd">        underneath the specified node. If u is a sample, it is included in the</span>
<span class="sd">        returned iterator. If u is not specified, return all samples in the tree.</span>

<span class="sd">        If the :meth:`TreeSequence.trees` method is called with</span>
<span class="sd">        ``sample_lists=True``, this method uses an efficient algorithm to find</span>
<span class="sd">        the samples. If not, a simple traversal based method is used.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: An iterator over all samples in the subtree rooted at u.</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_generator</span><span class="p">(</span><span class="n">root</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.num_children"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_children">[docs]</a>    <span class="k">def</span> <span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of children of the specified</span>
<span class="sd">        node (i.e. ``len(tree.children(u))``)</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of immediate children of the node u in this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples. The method name is inaccurate</span>
        <span class="c1"># as this will count the number of tracked _samples_. This is only provided to</span>
        <span class="c1"># avoid breaking existing code and should not be used in new code. We could</span>
        <span class="c1"># change this method to be semantically correct and just count the</span>
        <span class="c1"># number of leaves we hit in the leaves() iterator. However, this would</span>
        <span class="c1"># have the undesirable effect of making code that depends on the constant</span>
        <span class="c1"># time performance of get_num_leaves many times slower. So, the best option</span>
        <span class="c1"># is to leave this method as is, and to slowly deprecate it out. Once this</span>
        <span class="c1"># has been removed, we might add in a ``num_leaves`` method that returns the</span>
        <span class="c1"># length of the leaves() iterator as one would expect.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.num_samples"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_samples">[docs]</a>    <span class="k">def</span> <span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of samples in this tree underneath the specified</span>
<span class="sd">        node (including the node itself). If u is not specified return</span>
<span class="sd">        the total number of samples in the tree.</span>

<span class="sd">        This is a constant time operation.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of samples in the subtree rooted at u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_num_tracked_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_tracked_samples. The method name is inaccurate</span>
        <span class="c1"># as this will count the number of tracked _samples_. This is only provided to</span>
        <span class="c1"># avoid breaking existing code and should not be used in new code.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tracked_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_num_tracked_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_tracked_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tracked_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.num_tracked_samples"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_tracked_samples">[docs]</a>    <span class="k">def</span> <span class="nf">num_tracked_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of samples in the set specified in the</span>
<span class="sd">        ``tracked_samples`` parameter of the :meth:`TreeSequence.trees` method</span>
<span class="sd">        underneath the specified node. If the input node is not specified,</span>
<span class="sd">        return the total number of tracked samples in the tree.</span>

<span class="sd">        This is a constant time operation.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of samples within the set of tracked samples in</span>
<span class="sd">            the subtree rooted at u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_tracked_samples</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">u</span><span class="p">])</span>
        <span class="c1"># For perf we store these to avoid lookups in the tight loop</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
        <span class="n">extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">get_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="c1"># Note: the usual style is to be explicit about what we&#39;re testing</span>
        <span class="c1"># and use while len(stack) &gt; 0, but this form is slightly faster.</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pop</span><span class="p">()</span>
            <span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">get_children</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
            <span class="k">yield</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_postorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">u</span><span class="p">])</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">NULL</span>
        <span class="c1"># For perf we store these to avoid lookups in the tight loop</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
        <span class="n">extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">get_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="n">get_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span>
        <span class="c1"># Note: the usual style is to be explicit about what we&#39;re testing</span>
        <span class="c1"># and use while len(stack) &gt; 0, but this form is slightly faster.</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">parent</span> <span class="k">else</span> <span class="n">get_children</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">children</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_inorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># TODO add a nonrecursive version of the inorder traversal.</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[:</span><span class="n">mid</span><span class="p">]:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inorder_traversal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">u</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[</span><span class="n">mid</span><span class="p">:]:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inorder_traversal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_levelorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">u</span><span class="p">])</span>
        <span class="c1"># For perf we store these to avoid lookups in the tight loop</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">extend</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="c1"># Note: the usual style is to be explicit about what we&#39;re testing</span>
        <span class="c1"># and use while len(queue) &gt; 0, but this form is slightly faster.</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pop</span><span class="p">()</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_timeasc_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts by increasing time but falls back to increasing ID for equal times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_timedesc_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts by decreasing time but falls back to decreasing ID for equal times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">u</span><span class="p">),</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_minlex_postorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Postorder traversal that visits leaves in minimum lexicographic order.</span>

<span class="sd">        Minlex stands for minimum lexicographic. We wish to visit a tree in such</span>
<span class="sd">        a way that the leaves visited, when their IDs are listed out, have</span>
<span class="sd">        minimum lexicographic order. This is a useful ordering for drawing</span>
<span class="sd">        multiple Trees of a TreeSequence, as it leads to more consistency</span>
<span class="sd">        between adjacent Trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We skip perf optimisations here (compared to _preorder_traversal and</span>
        <span class="c1"># _postorder_traversal) as this ordering is unlikely to be used in perf</span>
        <span class="c1"># sensitive applications</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">u</span><span class="p">])</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">NULL</span>

        <span class="c1"># We compute a dictionary mapping from internal node ID to min leaf ID</span>
        <span class="c1"># under the node, using a first postorder traversal</span>
        <span class="n">min_leaf_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">parent</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="c1"># The first time visiting a node, we push its children onto the stack.</span>
                <span class="c1"># reversed is not strictly necessary, but it gives the postorder</span>
                <span class="c1"># we would intuitively expect.</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">children</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The second time visiting a node, we record its min leaf ID</span>
                <span class="c1"># underneath, pop it, and update the parent variable</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="c1"># at a leaf node</span>
                    <span class="n">min_leaf_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># at a parent after finishing all its children</span>
                    <span class="n">min_leaf_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">min_leaf_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># Now we do a second postorder traversal</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">u</span><span class="p">])</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">NULL</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">parent</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="c1"># The first time visiting a node, we push onto the stack its children</span>
                <span class="c1"># in order of reverse min leaf ID under each child. This guarantees</span>
                <span class="c1"># that the earlier children visited have smaller min leaf ID,</span>
                <span class="c1"># which is equivalent to the minlex condition.</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">min_leaf_dict</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The second time visiting a node, we pop and yield it, and</span>
                <span class="c1"># we update the parent variable</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.nodes"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the node IDs in this tree. If the root parameter</span>
<span class="sd">        is provided, iterate over the node IDs in the subtree rooted at this</span>
<span class="sd">        node. If this is None, iterate over all node IDs. If the order parameter</span>
<span class="sd">        is provided, iterate over the nodes in required tree traversal order.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Unlike the :meth:`TreeSequence.nodes` method, this iterator produces</span>
<span class="sd">            integer node IDs, not :class:`Node` objects.</span>

<span class="sd">        The currently implemented traversal orders are:</span>

<span class="sd">            - &#39;preorder&#39;: starting at root, yield the current node, then recurse</span>
<span class="sd">              and do a preorder on each child of the current node. See also `Wikipedia</span>
<span class="sd">              &lt;https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)&gt;`__.</span>
<span class="sd">            - &#39;inorder&#39;: starting at root, assuming binary trees, recurse and do</span>
<span class="sd">              an inorder on the first child, then yield the current node, then</span>
<span class="sd">              recurse and do an inorder on the second child. In the case of ``n``</span>
<span class="sd">              child nodes (not necessarily 2), the first ``n // 2`` children are</span>
<span class="sd">              visited in the first stage, and the remaining ``n - n // 2`` children</span>
<span class="sd">              are visited in the second stage. See also `Wikipedia</span>
<span class="sd">              &lt;https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)&gt;`__.</span>
<span class="sd">            - &#39;postorder&#39;: starting at root, recurse and do a postorder on each</span>
<span class="sd">              child of the current node, then yield the current node. See also</span>
<span class="sd">              `Wikipedia</span>
<span class="sd">              &lt;https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(LRN)&gt;`__.</span>
<span class="sd">            - &#39;levelorder&#39; (&#39;breadthfirst&#39;): visit the nodes under root (including</span>
<span class="sd">              the root) in increasing order of their depth from root. See also</span>
<span class="sd">              `Wikipedia</span>
<span class="sd">              &lt;https://en.wikipedia.org/wiki/Tree_traversal\</span>
<span class="sd">#Breadth-first_search_/_level_order&gt;`__.</span>
<span class="sd">            - &#39;timeasc&#39;: visits the nodes in order of increasing time, falling back to</span>
<span class="sd">              increasing ID if times are equal.</span>
<span class="sd">            - &#39;timedesc&#39;: visits the nodes in order of decreasing time, falling back to</span>
<span class="sd">              decreasing ID if times are equal.</span>
<span class="sd">            - &#39;minlex_postorder&#39;: a usual postorder has ambiguity in the order in</span>
<span class="sd">              which children of a node are visited. We constrain this by outputting</span>
<span class="sd">              a postorder such that the leaves visited, when their IDs are</span>
<span class="sd">              listed out, have minimum `lexicographic order</span>
<span class="sd">              &lt;https://en.wikipedia.org/wiki/Lexicographical_order&gt;`__ out of all valid</span>
<span class="sd">              traversals. This traversal is useful for drawing multiple trees of</span>
<span class="sd">              a ``TreeSequence``, as it leads to more consistency between adjacent</span>
<span class="sd">              trees. Note that internal non-leaf nodes are not counted in</span>
<span class="sd">              assessing the lexicographic order.</span>

<span class="sd">        :param int root: The root of the subtree we are traversing.</span>
<span class="sd">        :param str order: The traversal ordering. Currently &#39;preorder&#39;,</span>
<span class="sd">            &#39;inorder&#39;, &#39;postorder&#39;, &#39;levelorder&#39; (&#39;breadthfirst&#39;), &#39;timeasc&#39; and</span>
<span class="sd">            &#39;timedesc&#39; and &#39;minlex_postorder&#39; are supported.</span>
<span class="sd">        :return: An iterator over the node IDs in the tree in some traversal order.</span>
<span class="sd">        :rtype: collections.abc.Iterable, int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;preorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;inorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;postorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;levelorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levelorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;breadthfirst&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levelorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;timeasc&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeasc_traversal</span><span class="p">,</span>
            <span class="s2">&quot;timedesc&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timedesc_traversal</span><span class="p">,</span>
            <span class="s2">&quot;minlex_postorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minlex_postorder_traversal</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">methods</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Traversal ordering &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;minlex_postorder&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># we need to visit the roots in minlex order as well</span>
            <span class="c1"># we first visit all the roots and then sort by the min value</span>
            <span class="n">root_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="n">root_minlex_postorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">root_minlex_postorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">root_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">min_value</span><span class="p">,</span> <span class="n">root_minlex_postorder</span><span class="p">])</span>
            <span class="n">root_values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">nodes_for_root</span> <span class="ow">in</span> <span class="n">root_values</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">nodes_for_root</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">iterator</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>

    <span class="c1"># TODO make this a bit less embarrassing by using an iterative method.</span>
    <span class="k">def</span> <span class="nf">__build_newick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">node_labels</span><span class="p">,</span> <span class="n">include_branch_lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple recursive version of the newick generator used when non-default</span>
<span class="sd">        node labels are needed, or when branch lengths are omitted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">node_labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(&quot;</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">branch_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_newick</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
                    <span class="n">include_branch_lengths</span><span class="o">=</span><span class="n">include_branch_lengths</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">include_branch_lengths</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">+=</span> <span class="s2">&quot;:{0:.</span><span class="si">{1}</span><span class="s2">f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">branch_length</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">subtree</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;)</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Tree.newick"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.newick">[docs]</a>    <span class="k">def</span> <span class="nf">newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>  <span class="c1"># Should probably be keyword only, left positional for legacy use</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_branch_lengths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `newick encoding &lt;https://en.wikipedia.org/wiki/Newick_format&gt;`_</span>
<span class="sd">        of this tree. If the ``root`` argument is specified, return a representation</span>
<span class="sd">        of the specified subtree, otherwise the full tree is returned. If the tree</span>
<span class="sd">        has multiple roots then seperate newick strings for each rooted subtree</span>
<span class="sd">        must be found (i.e., we do not attempt to concatenate the different trees).</span>

<span class="sd">        By default, leaf nodes are labelled with their numerical ID + 1,</span>
<span class="sd">        and internal nodes are not labelled. Arbitrary node labels can be specified</span>
<span class="sd">        using the ``node_labels`` argument, which maps node IDs to the desired</span>
<span class="sd">        labels.</span>

<span class="sd">        .. warning:: Node labels are **not** Newick escaped, so care must be taken</span>
<span class="sd">            to provide labels that will not break the encoding.</span>

<span class="sd">        :param int precision: The numerical precision with which branch lengths are</span>
<span class="sd">            printed.</span>
<span class="sd">        :param int root: If specified, return the tree rooted at this node.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param include_branch_lengths: If True (default), output branch lengths in the</span>
<span class="sd">            Newick string. If False, only output the topology, without branch lengths.</span>
<span class="sd">        :return: A newick representation of this tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roots</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot get newick for multiroot trees. Try &quot;</span>
                    <span class="s2">&quot;[t.newick(root) for root in t.roots] to get a list of &quot;</span>
                    <span class="s2">&quot;newick trees, one for each root.&quot;</span>
                <span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_branch_lengths</span> <span class="ow">and</span> <span class="n">node_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># C code always puts branch lengths: force Py code by setting default labels</span>
            <span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">node_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
            <span class="n">max_label_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>
            <span class="n">single_node_size</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">4</span> <span class="o">+</span> <span class="n">max_label_size</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">root_time</span><span class="p">))</span> <span class="o">+</span> <span class="n">precision</span>
            <span class="p">)</span>
            <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">single_node_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_newick</span><span class="p">(</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">buffer_size</span>
            <span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__build_newick</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
                    <span class="n">include_branch_lengths</span><span class="o">=</span><span class="n">include_branch_lengths</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;;&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="Tree.as_dict_of_dicts"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.as_dict_of_dicts">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict_of_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tree to dict of dicts for conversion to a</span>
<span class="sd">        `networkx graph &lt;https://networkx.github.io/documentation/stable/</span>
<span class="sd">        reference/classes/digraph.html&gt;`_.</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">            &gt;&gt;&gt; nx.DiGraph(tree.as_dict_of_dicts())</span>
<span class="sd">            &gt;&gt;&gt; # undirected graphs work as well</span>
<span class="sd">            &gt;&gt;&gt; nx.Graph(tree.as_dict_of_dicts())</span>

<span class="sd">        :return: Dictionary of dictionaries of dictionaries where the first key</span>
<span class="sd">            is the source, the second key is the target of an edge, and the</span>
<span class="sd">            third key is an edge annotation. At this point the only annotation</span>
<span class="sd">            is &quot;branch_length&quot;, the length of the branch (in generations).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dod</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">dod</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
                <span class="n">dod</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;branch_length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">child</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">dod</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_parent_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">u</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NULL</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pi</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parent_dict</span><span class="p">())</span>

<div class="viewcode-block" id="Tree.map_mutations"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.map_mutations">[docs]</a>    <span class="k">def</span> <span class="nf">map_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">,</span> <span class="n">alleles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given observations for the samples in this tree described by the specified</span>
<span class="sd">        set of genotypes and alleles, return a parsimonious set of state transitions</span>
<span class="sd">        explaining these observations. The genotypes array is interpreted as indexes</span>
<span class="sd">        into the alleles list in the same manner as described in the</span>
<span class="sd">        :meth:`TreeSequence.variants` method. Thus, if sample ``j`` carries the</span>
<span class="sd">        allele at index ``k``, then we have ``genotypes[j] = k``.</span>
<span class="sd">        Missing observations can be specified for a sample using the value</span>
<span class="sd">        ``tskit.MISSING_DATA`` (-1), in which case the state at this sample does not</span>
<span class="sd">        influence the ancestral state or the position of mutations returned. At least</span>
<span class="sd">        one non-missing observation must be provided. A maximum of 64 alleles are</span>
<span class="sd">        supported.</span>

<span class="sd">        The current implementation uses the Fitch parsimony algorithm to determine</span>
<span class="sd">        the minimum number of state transitions required to explain the data. In this</span>
<span class="sd">        model, transitions between any of the non-missing states is equally likely.</span>

<span class="sd">        The returned values correspond directly to the data model for describing</span>
<span class="sd">        variation at sites using mutations. See the :ref:`sec_site_table_definition`</span>
<span class="sd">        and :ref:`sec_mutation_table_definition` definitions for details and background.</span>

<span class="sd">        The state reconstruction is returned as two-tuple, ``(ancestral_state,</span>
<span class="sd">        mutations)``, where ``ancestral_state`` is the allele assigned to the</span>
<span class="sd">        tree root(s) and ``mutations`` is a list of :class:`Mutation` objects,</span>
<span class="sd">        ordered as :ref:`required in a mutation table&lt;sec_mutation_requirements&gt;`.</span>
<span class="sd">        For each mutation, ``node`` is the tree node at the bottom of the branch</span>
<span class="sd">        on which the transition occurred, and ``derived_state`` is the new state</span>
<span class="sd">        after this mutation. The ``parent`` property contains the index in the</span>
<span class="sd">        returned list of the previous mutation on the path to root, or ``tskit.NULL``</span>
<span class="sd">        if there are no previous mutations (see the :ref:`sec_mutation_table_definition`</span>
<span class="sd">        for more information on the concept of mutation parents). All other attributes</span>
<span class="sd">        of the :class:`Mutation` object are undefined and should not be used.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Sample states observed as missing in the input ``genotypes`` need</span>
<span class="sd">            not correspond to samples whose nodes are actually &quot;missing&quot; (i.e.</span>
<span class="sd">            :ref:`isolated&lt;sec_data_model_missing_data&gt;`) in the tree. In this</span>
<span class="sd">            case, mapping the mutations returned by this method onto the tree</span>
<span class="sd">            will result in these missing observations being imputed to the</span>
<span class="sd">            most parsimonious state.</span>

<span class="sd">        See the :ref:`sec_tutorial_parsimony` section in the tutorial for examples</span>
<span class="sd">        of how to use this method.</span>

<span class="sd">        :param array_like genotypes: The input observations for the samples in this tree.</span>
<span class="sd">        :param tuple(str) alleles: The alleles for the specified ``genotypes``. Each</span>
<span class="sd">            positive value in the ``genotypes`` array is treated as an index into this</span>
<span class="sd">            list of alleles.</span>
<span class="sd">        :return: The inferred ancestral state and list of mutations on this tree</span>
<span class="sd">            that encode the specified observations.</span>
<span class="sd">        :rtype: (str, list(tskit.Mutation))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genotypes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">genotypes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A maximum of 64 states is supported&quot;</span><span class="p">)</span>
        <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">map_mutations</span><span class="p">(</span><span class="n">genotypes</span><span class="p">)</span>
        <span class="c1"># Translate back into string alleles</span>
        <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ancestral_state</span><span class="p">]</span>
        <span class="n">mutations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Mutation</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="o">=</span><span class="n">alleles</span><span class="p">[</span><span class="n">derived_state</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">derived_state</span> <span class="ow">in</span> <span class="n">transitions</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">mutations</span></div>

<div class="viewcode-block" id="Tree.kc_distance"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.kc_distance">[docs]</a>    <span class="k">def</span> <span class="nf">kc_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Kendall-Colijn distance between the specified pair of trees.</span>
<span class="sd">        The ``lambda_`` parameter  determines the relative weight of topology</span>
<span class="sd">        vs branch lengths in calculating the distance. If ``lambda_`` is 0</span>
<span class="sd">        (the default) we only consider topology, and if it is 1 we only</span>
<span class="sd">        consider branch lengths. See `Kendall &amp; Colijn (2016)</span>
<span class="sd">        &lt;https://academic.oup.com/mbe/article/33/10/2735/2925548&gt;`_ for details.</span>

<span class="sd">        The trees we are comparing to must have identical lists of sample</span>
<span class="sd">        nodes (i.e., the same IDs in the same order). The metric operates on</span>
<span class="sd">        samples, not leaves, so internal samples are treated identically to</span>
<span class="sd">        sample tips. Subtrees with no samples do not contribute to the metric.</span>

<span class="sd">        :param Tree other: The other tree to compare to.</span>
<span class="sd">        :param float lambda_: The KC metric lambda parameter determining the</span>
<span class="sd">            relative weight of topology and branch length.</span>
<span class="sd">        :return: The computed KC distance between this tree and other.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_kc_distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.split_polytomies"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.split_polytomies">[docs]</a>    <span class="k">def</span> <span class="nf">split_polytomies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`.Tree` where extra nodes and edges have been inserted</span>
<span class="sd">        so that any any node ``u`` with greater than 2 children --- a multifurcation</span>
<span class="sd">        or &quot;polytomy&quot; --- is resolved into successive bifurcations. New nodes are</span>
<span class="sd">        inserted at times fractionally less than than the time of node ``u``</span>
<span class="sd">        (controlled by the ``epsilon`` parameter).</span>

<span class="sd">        If the ``method`` is ``&quot;random&quot;`` (currently the only option, and the default</span>
<span class="sd">        when no method is specified), then for a node with :math:`n` children, the</span>
<span class="sd">        :math:`(2n - 3)! / (2^(n - 2) (n - 2!))` possible binary trees with equal</span>
<span class="sd">        probability.</span>

<span class="sd">        The returned :class`.Tree` will have the same genomic span as this tree,</span>
<span class="sd">        and node IDs will be conserved (that is, node ``u`` in this tree will</span>
<span class="sd">        be the same node in the returned tree). The returned tree is derived from a</span>
<span class="sd">        tree sequence that contains only one non-degenerate tree, that is, where</span>
<span class="sd">        edges cover only the interval spanned by this tree.</span>

<span class="sd">        .. note::</span>
<span class="sd">            A tree sequence :ref:`requires&lt;sec_valid_tree_sequence_requirements&gt;` that</span>
<span class="sd">            parents be older than children and that mutations are younger than the</span>
<span class="sd">            parent of the edge on which they lie. If ``epsilon`` is not small enough,</span>
<span class="sd">            compared to the distance between a polytomy and its oldest child (or oldest</span>
<span class="sd">            child mutation) these requirements may not be met. In this case an error is</span>
<span class="sd">            raised, recommending a smaller epsilon value be used.</span>

<span class="sd">        :param epsilon: A small time period used to separate each newly inserted node.</span>
<span class="sd">            For a given polytomy of degree :math:`n`, the :math:`n-2` extra nodes are</span>
<span class="sd">            inserted with the oldest at time ``epsilon`` less than the original parent,</span>
<span class="sd">            ``u``, and successive nodes at time ``epsilon`` from each other. Times</span>
<span class="sd">            are allocated to different levels of the tree, such that any newly</span>
<span class="sd">            inserted sibling nodes will have the same time. (Default :math:`1e-10`).</span>
<span class="sd">        :param str method: The method used to break polytomies. Currently only &quot;random&quot;</span>
<span class="sd">            is supported, which can also be specified by ``method=None``</span>
<span class="sd">            (Default: ``None``).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param int random_seed: The random seed. If this is None, a random seed will</span>
<span class="sd">            be automatically generated. Valid random seeds must be between 1 and</span>
<span class="sd">            :math:`2^32  1`.</span>
<span class="sd">        :return: A new tree with polytomies split into random bifurcations.</span>
<span class="sd">        :rtype: tskit.Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">split_polytomies</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Tree.generate_star"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_star">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_star</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:&lt;Tree&gt; whose leaf nodes all have the same parent (i.e.</span>
<span class="sd">        a &quot;star&quot; tree). The leaf nodes are all at time 0 and are marked as sample nodes.</span>

<span class="sd">        The tree produced by this method is identical to</span>
<span class="sd">        ``tskit.Tree.unrank(n, (0, 0))``, but generated more efficiently for large ``n``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:&lt;Tree&gt;.</span>
<span class="sd">        :param float branch_length: The length of every branch in the tree (equivalent</span>
<span class="sd">            to the time of the root node).</span>
<span class="sd">        :return: A star-shaped tree. Its corresponding :class:`TreeSequence` is available</span>
<span class="sd">            via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_star</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Tree.generate_balanced"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_balanced">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_balanced</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:&lt;Tree&gt; with the specified number of leaves that is maximally</span>
<span class="sd">        balanced. By default, the tree returned is binary, such that for each</span>
<span class="sd">        node that subtends :math:`n` leaves, the left child will subtend</span>
<span class="sd">        :math:`\\floor{n / 2}` leaves and the right child the remainder. Balanced</span>
<span class="sd">        trees with higher arity can also generated using the ``arity`` parameter,</span>
<span class="sd">        where the leaves subtending a node are distributed among its children</span>
<span class="sd">        analogously.</span>

<span class="sd">        In the returned tree, the leaf nodes are all at time 0, marked as samples,</span>
<span class="sd">        and labelled 0 to n from left-to-right. Internal node IDs are assigned</span>
<span class="sd">        sequentially from n in a postorder traversal, and the time of an internal</span>
<span class="sd">        node is the maximum time of its children plus the specified ``branch_length``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param int arity: The maximum number of children a node can have in the returned</span>
<span class="sd">            tree.</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:&lt;Tree&gt;.</span>
<span class="sd">        :param float branch_length: The minimum length of a branch in the tree (see</span>
<span class="sd">            above for details on how internal node times are assigned).</span>
<span class="sd">        :return: A balanced tree. Its corresponding :class:`TreeSequence` is available</span>
<span class="sd">            via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_balanced</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">arity</span><span class="o">=</span><span class="n">arity</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Tree.generate_comb"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_comb">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_comb</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:&lt;Tree&gt; in which all internal nodes have two children</span>
<span class="sd">        and the left child is a leaf. This is a &quot;comb&quot;, &quot;ladder&quot; or &quot;pectinate&quot;</span>
<span class="sd">        phylogeny, and also known as a `caterpiller tree</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Caterpillar_tree&gt;`_.</span>

<span class="sd">        The leaf nodes are all at time 0, marked as samples,</span>
<span class="sd">        and labelled 0 to n from left-to-right. Internal node IDs are assigned</span>
<span class="sd">        sequentially from n as we ascend the tree, and the time of an internal</span>
<span class="sd">        node is the maximum time of its children plus the specified ``branch_length``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:&lt;Tree&gt;.</span>
<span class="sd">        :param float branch_length: The length of every branch in the tree (equivalent</span>
<span class="sd">            to the time of the root node).</span>
<span class="sd">        :return: A star-shaped tree. Its corresponding :class:`TreeSequence` is available</span>
<span class="sd">            via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_comb</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Tree.generate_random_binary"><a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_random_binary">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_random_binary</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a random binary :class:&lt;Tree&gt; with :math:`n` = ``num_leaves``</span>
<span class="sd">        leaves with an equal probability of returning any topology and</span>
<span class="sd">        leaf label permutation among the :math:`(2n - 3)! / (2^(n - 2) (n - 2!))`</span>
<span class="sd">        leaf-labelled binary trees.</span>

<span class="sd">        The leaf nodes are marked as samples, labelled 0 to n, and placed at</span>
<span class="sd">        time 0. Internal node IDs are assigned sequentially from n as we ascend</span>
<span class="sd">        the tree, and the time of an internal node is the maximum time of its</span>
<span class="sd">        children plus the specified ``branch_length``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The returned tree has not been created under any explicit model of</span>
<span class="sd">            evolution. In order to simulate such trees, additional software</span>
<span class="sd">            such as `msprime &lt;https://github.com/tskit-dev/msprime&gt;`` is required.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:&lt;Tree&gt;.</span>
<span class="sd">        :param float branch_length: The time separating successive non-leaf nodes</span>
<span class="sd">            from each other.</span>
<span class="sd">        :return: A random binary tree. Its corresponding :class:`TreeSequence` is</span>
<span class="sd">            available via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_random_binary</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../python-api.html#tskit.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads a tree sequence from the specified file object or path. The file must be in the</span>
<span class="sd">    :ref:`tree sequence file format &lt;sec_tree_sequence_file_format&gt;` produced by the</span>
<span class="sd">    :meth:`TreeSequence.dump` method.</span>

<span class="sd">    :param str file: The file object or path of the ``.trees`` file containing the</span>
<span class="sd">        tree sequence we wish to load.</span>
<span class="sd">    :return: The tree sequence object containing the information</span>
<span class="sd">        stored in the specified file path.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TreeSequence</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_individuals"><a class="viewcode-back" href="../../python-api.html#tskit.parse_individuals">[docs]</a><span class="k">def</span> <span class="nf">parse_individuals</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of an individual table and returns the corresponding</span>
<span class="sd">    :class:`IndividualTable` instance. See the :ref:`individual text format</span>
<span class="sd">    &lt;sec_individual_text_format&gt;` section for the details of the required</span>
<span class="sd">    format and the :ref:`individual table definition</span>
<span class="sd">    &lt;sec_individual_table_definition&gt;` section for the required properties of</span>
<span class="sd">    the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param IndividualTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`IndividualTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">IndividualTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">flags_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;flags&quot;</span><span class="p">)</span>
    <span class="n">location_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">location_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;location&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">flags_index</span><span class="p">])</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">if</span> <span class="n">location_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">location_string</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">location_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location_string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">location</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">location_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="parse_nodes"><a class="viewcode-back" href="../../python-api.html#tskit.parse_nodes">[docs]</a><span class="k">def</span> <span class="nf">parse_nodes</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a node table and returns the corresponding :class:`NodeTable`</span>
<span class="sd">    instance. See the :ref:`node text format &lt;sec_node_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`node table definition &lt;sec_node_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param NodeTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`NodeTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">NodeTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">is_sample_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;is_sample&quot;</span><span class="p">)</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="n">population_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">individual_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">population_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;population&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">individual_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;individual&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">is_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">is_sample_index</span><span class="p">])</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">])</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">is_sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">NODE_IS_SAMPLE</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">NULL</span>
            <span class="k">if</span> <span class="n">population_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">population</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">population_index</span><span class="p">])</span>
            <span class="n">individual</span> <span class="o">=</span> <span class="n">NULL</span>
            <span class="k">if</span> <span class="n">individual_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">individual</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">individual_index</span><span class="p">])</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="parse_edges"><a class="viewcode-back" href="../../python-api.html#tskit.parse_edges">[docs]</a><span class="k">def</span> <span class="nf">parse_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a edge table and returns the corresponding :class:`EdgeTable`</span>
<span class="sd">    instance. See the :ref:`edge text format &lt;sec_edge_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`edge table definition &lt;sec_edge_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict`` parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param EdgeTable table: If specified, write the edges into this table. If</span>
<span class="sd">        not, create a new :class:`EdgeTable` instance and return.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">EdgeTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">left_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">right_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">parent_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
    <span class="n">children_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">left_index</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">right_index</span><span class="p">])</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">parent_index</span><span class="p">])</span>
            <span class="n">children</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="n">children_index</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="parse_sites"><a class="viewcode-back" href="../../python-api.html#tskit.parse_sites">[docs]</a><span class="k">def</span> <span class="nf">parse_sites</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a site table and returns the corresponding :class:`SiteTable`</span>
<span class="sd">    instance. See the :ref:`site text format &lt;sec_site_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`site table definition &lt;sec_site_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param SiteTable table: If specified write site into this table. If not,</span>
<span class="sd">        create a new :class:`SiteTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">SiteTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">position_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">)</span>
    <span class="n">ancestral_state_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ancestral_state&quot;</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">position_index</span><span class="p">])</span>
            <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">ancestral_state_index</span><span class="p">]</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="parse_mutations"><a class="viewcode-back" href="../../python-api.html#tskit.parse_mutations">[docs]</a><span class="k">def</span> <span class="nf">parse_mutations</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a mutation table and returns the corresponding :class:`MutationTable`</span>
<span class="sd">    instance. See the :ref:`mutation text format &lt;sec_mutation_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`mutation table definition &lt;sec_mutation_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents. Note that if the ``time`` column is missing its</span>
<span class="sd">    entries are filled with ``UNKNOWN_TIME``.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param MutationTable table: If specified, write mutations into this table.</span>
<span class="sd">        If not, create a new :class:`MutationTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">MutationTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">site_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;site&quot;</span><span class="p">)</span>
    <span class="n">node_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;node&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">derived_state_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;derived_state&quot;</span><span class="p">)</span>
    <span class="n">parent_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">NULL</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parent_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">site_index</span><span class="p">])</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">node_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">time_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;unknown&quot;</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">UNKNOWN_TIME</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">])</span>
            <span class="n">derived_state</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">derived_state_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">parent_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">parent_index</span><span class="p">])</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="parse_populations"><a class="viewcode-back" href="../../python-api.html#tskit.parse_populations">[docs]</a><span class="k">def</span> <span class="nf">parse_populations</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a population table and returns the corresponding</span>
<span class="sd">    :class:`PopulationTable` instance. See the :ref:`population text format</span>
<span class="sd">    &lt;sec_population_text_format&gt;` section for the details of the required</span>
<span class="sd">    format and the :ref:`population table definition</span>
<span class="sd">    &lt;sec_population_table_definition&gt;` section for the required properties of</span>
<span class="sd">    the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param PopulationTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`PopulationTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">PopulationTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="load_text"><a class="viewcode-back" href="../../python-api.html#tskit.load_text">[docs]</a><span class="k">def</span> <span class="nf">load_text</span><span class="p">(</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>
    <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span>
    <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses the tree sequence data from the specified file-like objects, and</span>
<span class="sd">    returns the resulting :class:`TreeSequence` object. The format</span>
<span class="sd">    for these files is documented in the :ref:`sec_text_file_format` section,</span>
<span class="sd">    and is produced by the :meth:`TreeSequence.dump_text` method. Further</span>
<span class="sd">    properties required for an input tree sequence are described in the</span>
<span class="sd">    :ref:`sec_valid_tree_sequence_requirements` section. This method is intended as a</span>
<span class="sd">    convenient interface for importing external data into tskit; the binary</span>
<span class="sd">    file format using by :meth:`tskit.load` is many times more efficient than</span>
<span class="sd">    this text format.</span>

<span class="sd">    The ``nodes`` and ``edges`` parameters are mandatory and must be file-like</span>
<span class="sd">    objects containing text with whitespace delimited columns,  parsable by</span>
<span class="sd">    :func:`parse_nodes` and :func:`parse_edges`, respectively. ``sites``,</span>
<span class="sd">    ``mutations``, ``individuals`` and ``populations`` are optional, and must</span>
<span class="sd">    be parsable by :func:`parse_sites`, :func:`parse_individuals`,</span>
<span class="sd">    :func:`parse_populations`, and :func:`parse_mutations`, respectively.</span>

<span class="sd">    The ``sequence_length`` parameter determines the</span>
<span class="sd">    :attr:`TreeSequence.sequence_length` of the returned tree sequence. If it</span>
<span class="sd">    is 0 or not specified, the value is taken to be the maximum right</span>
<span class="sd">    coordinate of the input edges. This parameter is useful in degenerate</span>
<span class="sd">    situations (such as when there are zero edges), but can usually be ignored.</span>

<span class="sd">    The ``strict`` parameter controls the field delimiting algorithm that</span>
<span class="sd">    is used. If ``strict`` is True (the default), we require exactly one</span>
<span class="sd">    tab character separating each field. If ``strict`` is False, a more relaxed</span>
<span class="sd">    whitespace delimiting algorithm is used, such that any run of whitespace</span>
<span class="sd">    is regarded as a field separator. In most situations, ``strict=False``</span>
<span class="sd">    is more convenient, but it can lead to error in certain situations. For</span>
<span class="sd">    example, if a deletion is encoded in the mutation table this will not</span>
<span class="sd">    be parseable when ``strict=False``.</span>

<span class="sd">    After parsing the tables, :meth:`TableCollection.sort` is called to ensure that</span>
<span class="sd">    the loaded tables satisfy the tree sequence :ref:`ordering requirements</span>
<span class="sd">    &lt;sec_valid_tree_sequence_requirements&gt;`. Note that this may result in the</span>
<span class="sd">    IDs of various entities changing from their positions in the input file.</span>

<span class="sd">    :param io.TextIOBase nodes: The file-like object containing text describing a</span>
<span class="sd">        :class:`NodeTable`.</span>
<span class="sd">    :param io.TextIOBase edges: The file-like object containing text</span>
<span class="sd">        describing an :class:`EdgeTable`.</span>
<span class="sd">    :param io.TextIOBase sites: The file-like object containing text describing a</span>
<span class="sd">        :class:`SiteTable`.</span>
<span class="sd">    :param io.TextIOBase mutations: The file-like object containing text</span>
<span class="sd">        describing a :class:`MutationTable`.</span>
<span class="sd">    :param io.TextIOBase individuals: The file-like object containing text</span>
<span class="sd">        describing a :class:`IndividualTable`.</span>
<span class="sd">    :param io.TextIOBase populations: The file-like object containing text</span>
<span class="sd">        describing a :class:`PopulationTable`.</span>
<span class="sd">    :param float sequence_length: The sequence length of the returned tree sequence. If</span>
<span class="sd">        not supplied or zero this will be inferred from the set of edges.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :return: The tree sequence object containing the information</span>
<span class="sd">        stored in the specified file paths.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We need to parse the edges so we can figure out the sequence length, and</span>
    <span class="c1"># TableCollection.sequence_length is immutable so we need to create a temporary</span>
    <span class="c1"># edge table.</span>
    <span class="n">edge_table</span> <span class="o">=</span> <span class="n">parse_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sequence_length</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">edge_table</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tc</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
    <span class="n">tc</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
        <span class="n">left</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
        <span class="n">child</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parse_nodes</span><span class="p">(</span>
        <span class="n">nodes</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
        <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
        <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># We need to add populations any referenced in the node table.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">max_population</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_population</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_population</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tc</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_sites</span><span class="p">(</span>
            <span class="n">sites</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">mutations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_mutations</span><span class="p">(</span>
            <span class="n">mutations</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_individuals</span><span class="p">(</span>
            <span class="n">individuals</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">populations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_populations</span><span class="p">(</span>
            <span class="n">populations</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">tc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tc</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">TreeIterator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple class providing forward and backward iteration over a tree sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">prev</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_trees</span>


<span class="k">class</span> <span class="nc">SimpleContainerSequence</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple wrapper to allow arrays of SimpleContainers (e.g. edges, nodes) that have a</span>
<span class="sd">    function allowing access by index (e.g. ts.edge(i), ts.node(i)) to be treated as a</span>
<span class="sd">    python sequence, allowing forward and reverse iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getter</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getter</span> <span class="o">=</span> <span class="n">getter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getter</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>


<div class="viewcode-block" id="TreeSequence"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence">[docs]</a><span class="k">class</span> <span class="nc">TreeSequence</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single tree sequence, as defined by the :ref:`data model &lt;sec_data_model&gt;`.</span>
<span class="sd">    A TreeSequence instance can be created from a set of</span>
<span class="sd">    :ref:`tables &lt;sec_table_definitions&gt;` using</span>
<span class="sd">    :meth:`TableCollection.tree_sequence`, or loaded from a set of text files</span>
<span class="sd">    using :func:`tskit.load_text`, or loaded from a native binary file using</span>
<span class="sd">    :func:`tskit.load`.</span>

<span class="sd">    TreeSequences are immutable. To change the data held in a particular</span>
<span class="sd">    tree sequence, first get the table information as a :class:`TableCollection`</span>
<span class="sd">    instance (using :meth:`.dump_tables`), edit those tables using the</span>
<span class="sd">    :ref:`tables api &lt;sec_tables_api&gt;`, and create a new tree sequence using</span>
<span class="sd">    :meth:`TableCollection.tree_sequence`.</span>

<span class="sd">    The :meth:`.trees` method iterates over all trees in a tree sequence, and</span>
<span class="sd">    the :meth:`.variants` method iterates over all sites and their genotypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">class</span> <span class="nc">_TableMetadataSchemas</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience class for returning schemas</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">node</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">edge</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">site</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">mutation</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">migration</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">individual</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>
        <span class="n">population</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_tree_sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span> <span class="o">=</span> <span class="n">ll_tree_sequence</span>
        <span class="n">metadata_schema_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_table_metadata_schemas</span><span class="p">()</span>
        <span class="n">metadata_schema_instances</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">metadata_schema_strings</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_TableMetadataSchemas</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_metadata_schemas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TableMetadataSchemas</span><span class="p">(</span>
            <span class="o">**</span><span class="n">metadata_schema_instances</span>
        <span class="p">)</span>

    <span class="c1"># Implement the pickle protocol for TreeSequence</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span><span class="o">.</span><span class="n">ll_tree_sequence</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tables</span>

<div class="viewcode-block" id="TreeSequence.equals"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.equals">[docs]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if  `self` and `other` are equal. Uses the underlying table equlity,</span>
<span class="sd">        see :meth:`TableCollection.equals` for details and options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">tables</span><span class="p">,</span>
            <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
            <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
            <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
            <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ll_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ll_tree_sequence</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_ll_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span>

<div class="viewcode-block" id="TreeSequence.aslist"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.aslist">[docs]</a>    <span class="k">def</span> <span class="nf">aslist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the trees in this tree sequence as a list. Each tree is</span>
<span class="sd">        represented by a different instance of :class:`Tree`. As such, this</span>
<span class="sd">        method is inefficient and may use a large amount of memory, and should</span>
<span class="sd">        not be used when performance is a consideration. The :meth:`.trees`</span>
<span class="sd">        method is the recommended way to efficiently iterate over the trees</span>
<span class="sd">        in a tree sequence.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned trees. For example ``ts.aslist(sample_lists=True)`` will result</span>
<span class="sd">            in a list of :class:`Tree` instances created with ``sample_lists=True``.</span>
<span class="sd">        :return: A list of the trees in this tree sequence.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">):</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">()</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># TODO Fix this for new file semantics</span>
            <span class="n">formats</span><span class="o">.</span><span class="n">raise_hdf5_format_error</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_tables</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">build_indexes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">()</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">,</span> <span class="n">build_indexes</span><span class="o">=</span><span class="n">build_indexes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.dump"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the tree sequence to the specified path or file object.</span>

<span class="sd">        :param str file_or_path: The file object or path to write the TreeSequence to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tables_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping names to tables in the</span>
<span class="sd">        underlying :class:`.TableCollection`. Equivalent to calling</span>
<span class="sd">        ``ts.tables.name_map``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">name_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A copy of the tables underlying this tree sequence. See also</span>
<span class="sd">        :meth:`.dump_tables`.</span>

<span class="sd">        .. warning:: This propery currently returns a copy of the tables</span>
<span class="sd">            underlying a tree sequence but it may return a read-only</span>
<span class="sd">            **view** in the future. Thus, if the tables will subsequently be</span>
<span class="sd">            updated, please use the :meth:`.dump_tables` method instead as</span>
<span class="sd">            this will always return a new copy of the TableCollection.</span>

<span class="sd">        :return: A :class:`TableCollection` containing all a copy of the</span>
<span class="sd">            tables underlying this tree sequence.</span>
<span class="sd">        :rtype: TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of bytes required to store the data</span>
<span class="sd">        in this tree sequence. Note that this may not be equal to</span>
<span class="sd">        the actual memory footprint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nbytes</span>

<div class="viewcode-block" id="TreeSequence.dump_tables"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump_tables">[docs]</a>    <span class="k">def</span> <span class="nf">dump_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A copy of the tables defining this tree sequence.</span>

<span class="sd">        :return: A :class:`TableCollection` containing all tables underlying</span>
<span class="sd">            the tree sequence.</span>
<span class="sd">        :rtype: TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="TreeSequence.dump_text"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump_text">[docs]</a>    <span class="k">def</span> <span class="nf">dump_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span>
        <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a text representation of the tables underlying the tree sequence</span>
<span class="sd">        to the specified connections.</span>

<span class="sd">        If Base64 encoding is not used, then metadata will be saved directly, possibly</span>
<span class="sd">        resulting in errors reading the tables back in if metadata includes whitespace.</span>

<span class="sd">        :param io.TextIOBase nodes: The file-like object (having a .write() method) to</span>
<span class="sd">            write the NodeTable to.</span>
<span class="sd">        :param io.TextIOBase edges: The file-like object to write the EdgeTable to.</span>
<span class="sd">        :param io.TextIOBase sites: The file-like object to write the SiteTable to.</span>
<span class="sd">        :param io.TextIOBase mutations: The file-like object to write the</span>
<span class="sd">            MutationTable to.</span>
<span class="sd">        :param io.TextIOBase individuals: The file-like object to write the</span>
<span class="sd">            IndividualTable to.</span>
<span class="sd">        :param io.TextIOBase populations: The file-like object to write the</span>
<span class="sd">            PopulationTable to.</span>
<span class="sd">        :param io.TextIOBase provenances: The file-like object to write the</span>
<span class="sd">            ProvenanceTable to.</span>
<span class="sd">        :param int precision: The number of digits of precision.</span>
<span class="sd">        :param str encoding: Encoding used for text representation.</span>
<span class="sd">        :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">            encoding; otherwise, as plain text.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_sample&quot;</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;population&quot;</span><span class="p">,</span>
                <span class="s2">&quot;individual&quot;</span><span class="p">,</span>
                <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">file</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">metadata</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{id:d}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{is_sample:d}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;{time:.</span><span class="si">{precision}</span><span class="s2">f}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{population:d}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{individual:d}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{metadata}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">is_sample</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(),</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">individual</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">individual</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;{left:.</span><span class="si">{precision}</span><span class="s2">f}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;{right:.</span><span class="si">{precision}</span><span class="s2">f}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{parent:d}</span><span class="se">\t</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="si">{child:d}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                    <span class="n">right</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                    <span class="n">parent</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                    <span class="n">child</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;ancestral_state&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sites</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">metadata</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;{position:.</span><span class="si">{precision}</span><span class="s2">f}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{ancestral_state}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{metadata}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                    <span class="n">ancestral_state</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sites</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mutations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;site&quot;</span><span class="p">,</span>
                <span class="s2">&quot;node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;derived_state&quot;</span><span class="p">,</span>
                <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
                <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">file</span><span class="o">=</span><span class="n">mutations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">mutation</span><span class="o">.</span><span class="n">metadata</span>
                    <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                        <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{site}</span><span class="se">\t</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;</span><span class="si">{node}</span><span class="se">\t</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;</span><span class="si">{time}</span><span class="se">\t</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;</span><span class="si">{derived_state}</span><span class="se">\t</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;</span><span class="si">{parent}</span><span class="se">\t</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;</span><span class="si">{metadata}</span><span class="s2">&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">site</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">site</span><span class="p">,</span>
                        <span class="n">node</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                        <span class="n">time</span><span class="o">=</span><span class="s2">&quot;unknown&quot;</span>
                        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">mutation</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">mutation</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                        <span class="n">derived_state</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">derived_state</span><span class="p">,</span>
                        <span class="n">parent</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">mutations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">individuals</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">individual</span><span class="o">.</span><span class="n">metadata</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">individual</span><span class="o">.</span><span class="n">location</span><span class="p">))</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{flags}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{location}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{metadata}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
                    <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">individuals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">populations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">populations</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">():</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">metadata</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{metadata}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">population</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">populations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">provenances</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;record&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">provenances</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">provenance</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{timestamp}</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">{record}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">provenance</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">timestamp</span><span class="o">=</span><span class="n">provenance</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
                    <span class="n">record</span><span class="o">=</span><span class="n">provenance</span><span class="o">.</span><span class="n">record</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">provenances</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts_rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;Trees&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Sequence Length&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Sample Nodes&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Total Size&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)],</span>
        <span class="p">]</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Table&quot;</span><span class="p">,</span> <span class="s2">&quot;Rows&quot;</span><span class="p">,</span> <span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="s2">&quot;Has Metadata&quot;</span><span class="p">]</span>
        <span class="n">table_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">name_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">table_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
                        <span class="n">table</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span>
                        <span class="n">util</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">nbytes</span><span class="p">),</span>
                        <span class="s2">&quot;Yes&quot;</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">else</span> <span class="s2">&quot;No&quot;</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span><span class="n">ts_rows</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;TreeSequence&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span>
            <span class="n">table_rows</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by jupyter notebooks to render a TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">tree_sequence_html</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># num_samples was originally called sample_size, and so we must keep sample_size</span>
    <span class="c1"># around as a deprecated alias.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of samples in this tree sequence. This is the number</span>
<span class="sd">        of sample nodes in each tree.</span>

<span class="sd">        :return: The number of sample nodes in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">table_metadata_schemas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_TableMetadataSchemas&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The set of metadata schemas for the tables in this tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_metadata_schemas</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

    <span class="k">def</span> <span class="nf">get_sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">file_uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_file_uuid</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sequence length in this tree sequence. This defines the</span>
<span class="sd">        genomic scale over which tree coordinates are defined. Given a</span>
<span class="sd">        tree sequence with a sequence length :math:`L`, the constituent</span>
<span class="sd">        trees will be defined over the half-closed interval</span>
<span class="sd">        :math:`[0, L)`. Each tree then covers some subset of this</span>
<span class="sd">        interval --- see :attr:`tskit.Tree.interval` for details.</span>

<span class="sd">        :return: The length of the sequence in this tree sequence in bases.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The decoded metadata for this TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`tskit.MetadataSchema` for this TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_metadata_schema</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`edges &lt;sec_edge_table_definition&gt;` in this</span>
<span class="sd">        tree sequence.</span>

<span class="sd">        :return: The number of edges in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_edges</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_num_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_trees</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of distinct trees in this tree sequence. This</span>
<span class="sd">        is equal to the number of trees returned by the :meth:`.trees`</span>
<span class="sd">        method.</span>

<span class="sd">        :return: The number of trees in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_trees</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_sites</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`sites &lt;sec_site_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of sites in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_mutations</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`mutations &lt;sec_mutation_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of mutations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_mutations</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_nodes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`individuals &lt;sec_individual_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of individuals in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_individuals</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`nodes &lt;sec_node_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of nodes in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`provenances &lt;sec_provenance_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of provenances in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_provenances</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`populations &lt;sec_population_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of populations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_populations</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`migrations &lt;sec_migration_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of migrations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_migrations</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_root_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns time of the oldest root in any of the trees in this tree sequence.</span>
<span class="sd">        This is usually equal to ``np.max(ts.tables.nodes.time)`` but may not be</span>
<span class="sd">        since there can be nodes that are not present in any tree. Consistent</span>
<span class="sd">        with the definition of tree roots, if there are no edges in the tree</span>
<span class="sd">        sequence we return the time of the oldest sample.</span>

<span class="sd">        :return: The maximum time of a root in this tree sequence.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Edges are guaranteed to be listed in parent-time order, so we can get the</span>
            <span class="c1"># last one to get the oldest root.</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># However, we can have situations where there is a sample older than a</span>
            <span class="c1"># &#39;proper&#39; root</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="TreeSequence.migrations"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.migrations">[docs]</a>    <span class="k">def</span> <span class="nf">migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`migrations &lt;sec_migration_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        Migrations are returned in nondecreasing order of the ``time`` value.</span>

<span class="sd">        :return: An iterable sequence of all migrations.</span>
<span class="sd">        :rtype: Sequence(:class:`.Migration`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_migrations</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.individuals"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.individuals">[docs]</a>    <span class="k">def</span> <span class="nf">individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`individuals &lt;sec_individual_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all individuals.</span>
<span class="sd">        :rtype: Sequence(:class:`.Individual`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individual</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.nodes"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`nodes &lt;sec_node_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all nodes.</span>
<span class="sd">        :rtype: Sequence(:class:`.Node`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.edges"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`edges &lt;sec_edge_table_definition&gt;`</span>
<span class="sd">        in this tree sequence. Edges are returned in the order required</span>
<span class="sd">        for a :ref:`valid tree sequence &lt;sec_valid_tree_sequence_requirements&gt;`. So,</span>
<span class="sd">        edges are guaranteed to be ordered such that (a) all parents with a</span>
<span class="sd">        given ID are contiguous; (b) edges are returned in non-descreasing</span>
<span class="sd">        order of parent time ago; (c) within the edges for a given parent, edges</span>
<span class="sd">        are sorted first by child ID and then by left coordinate.</span>

<span class="sd">        :return: An iterable sequence of all edges.</span>
<span class="sd">        :rtype: Sequence(:class:`.Edge`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">edgesets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO the order that these records are returned in is not well specified.</span>
        <span class="c1"># Hopefully this does not matter, and we can just state that the ordering</span>
        <span class="c1"># should not be depended on.</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">active_edgesets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_diffs</span><span class="p">():</span>
            <span class="c1"># Complete and return any edgesets that are affected by this tree</span>
            <span class="c1"># transition</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">active_edgesets</span><span class="p">:</span>
                    <span class="n">edgeset</span> <span class="o">=</span> <span class="n">active_edgesets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="n">edgeset</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">left</span>
                    <span class="n">edgeset</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">parent</span><span class="p">])</span>
                    <span class="k">yield</span> <span class="n">edgeset</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_out</span><span class="p">:</span>
                <span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_in</span><span class="p">:</span>
                <span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="c1"># Update the active edgesets</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">active_edgesets</span>
                <span class="p">):</span>
                    <span class="n">active_edgesets</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">Edgeset</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">active_edgesets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">active_edgesets</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
            <span class="n">edgeset</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="n">edgeset</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">edgeset</span><span class="o">.</span><span class="n">parent</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">edgeset</span>

<div class="viewcode-block" id="TreeSequence.edge_diffs"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edge_diffs">[docs]</a>    <span class="k">def</span> <span class="nf">edge_diffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_terminal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the edges that are inserted and removed to</span>
<span class="sd">        build the trees as we move from left-to-right along the tree sequence.</span>
<span class="sd">        The iterator yields a sequence of 3-tuples, ``(interval, edges_out,</span>
<span class="sd">        edges_in)``. The ``interval`` is a pair ``(left, right)`` representing</span>
<span class="sd">        the genomic interval (see :attr:`Tree.interval`). The ``edges_out``</span>
<span class="sd">        value is a list of the edges that were just-removed to create the tree</span>
<span class="sd">        covering the interval (hence ``edges_out`` will always be empty for the</span>
<span class="sd">        first tree). The ``edges_in`` value is a list of edges that were just</span>
<span class="sd">        inserted to construct the tree covering the current interval.</span>

<span class="sd">        The edges returned within each ``edges_in`` list are ordered by ascending</span>
<span class="sd">        time of the parent node, then ascending parent id, then ascending child id.</span>
<span class="sd">        The edges within each ``edges_out`` list are the reverse order (e.g.</span>
<span class="sd">        descending parent time, parent id, then child_id). This means that within</span>
<span class="sd">        each list, edges with the same parent appear consecutively.</span>

<span class="sd">        :param bool include_terminal: If False (default), the iterator terminates</span>
<span class="sd">            after the final interval in the tree sequence (i.e. it does not</span>
<span class="sd">            report a final removal of all remaining edges), and the number</span>
<span class="sd">            of iterations will be equal to the number of trees in the tree</span>
<span class="sd">            sequence. If True, an additional iteration takes place, with the last</span>
<span class="sd">            ``edges_out`` value reporting all the edges contained in the final</span>
<span class="sd">            tree (with both ``left`` and ``right`` equal to the sequence length).</span>
<span class="sd">        :return: An iterator over the (interval, edges_out, edges_in) tuples.</span>
<span class="sd">        :rtype: :class:`collections.abc.Iterable`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TreeDiffIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="p">,</span> <span class="n">include_terminal</span><span class="p">)</span>
        <span class="n">metadata_decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">decode_row</span>
        <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">edge_tuples_out</span><span class="p">,</span> <span class="n">edge_tuples_in</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">edges_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">Edge</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="p">(</span><span class="n">metadata_decoder</span><span class="p">,)))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_tuples_out</span><span class="p">]</span>
            <span class="n">edges_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">Edge</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="p">(</span><span class="n">metadata_decoder</span><span class="p">,)))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_tuples_in</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">interval</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span></div>

<div class="viewcode-block" id="TreeSequence.sites"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.sites">[docs]</a>    <span class="k">def</span> <span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`sites &lt;sec_site_table_definition&gt;`</span>
<span class="sd">        in this tree sequence. Sites are returned in order of increasing ID</span>
<span class="sd">        (and also position). See the :class:`Site` class for details on</span>
<span class="sd">        the available fields for each site.</span>

<span class="sd">        :return: An iterable sequence of all sites.</span>
<span class="sd">        :rtype: Sequence(:class:`.Site`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.mutations"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mutations">[docs]</a>    <span class="k">def</span> <span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the</span>
<span class="sd">        :ref:`mutations &lt;sec_mutation_table_definition&gt;` in this tree sequence.</span>
<span class="sd">        Mutations are returned in order of nondecreasing site ID.</span>
<span class="sd">        See the :class:`Mutation` class for details on the available fields for</span>
<span class="sd">        each mutation.</span>

<span class="sd">        The returned iterator is equivalent to iterating over all sites</span>
<span class="sd">        and all mutations in each site, i.e.::</span>

<span class="sd">            &gt;&gt;&gt; for site in tree_sequence.sites():</span>
<span class="sd">            &gt;&gt;&gt;     for mutation in site.mutations:</span>
<span class="sd">            &gt;&gt;&gt;         yield mutation</span>

<span class="sd">        :return: An iterator over all mutations in this tree sequence.</span>
<span class="sd">        :rtype: iter(:class:`Mutation`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">add_deprecated_mutation_attrs</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">mutation</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.populations"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.populations">[docs]</a>    <span class="k">def</span> <span class="nf">populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`populations &lt;sec_population_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all populations.</span>
<span class="sd">        :rtype: Sequence(:class:`.Population`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.provenances"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.provenances">[docs]</a>    <span class="k">def</span> <span class="nf">provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`provenances &lt;sec_provenance_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all provenances.</span>
<span class="sd">        :rtype: Sequence(:class:`.Provenance`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.breakpoints"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.breakpoints">[docs]</a>    <span class="k">def</span> <span class="nf">breakpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the breakpoints along the chromosome, including the two extreme points</span>
<span class="sd">        0 and L. This is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; iter([0] + [t.interval.right for t in self.trees()])</span>

<span class="sd">        By default we return an iterator over the breakpoints as Python float objects;</span>
<span class="sd">        if ``as_array`` is True we return them as a numpy array.</span>

<span class="sd">        Note that the ``as_array`` form will be more efficient and convenient in most</span>
<span class="sd">        cases; the default iterator behaviour is mainly kept to ensure compatability</span>
<span class="sd">        with existing code.</span>

<span class="sd">        :param bool as_array: If True, return the breakpoints as a numpy array.</span>
<span class="sd">        :return: The breakpoints defined by the tree intervals along the sequence.</span>
<span class="sd">        :rtype: collections.abc.Iterable or numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">get_breakpoints</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_array</span><span class="p">:</span>
            <span class="c1"># Convert to Python floats for backward compatibility.</span>
            <span class="n">breakpoints</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">breakpoints</span></div>

<div class="viewcode-block" id="TreeSequence.at"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.at">[docs]</a>    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree covering the specified genomic location. The returned tree</span>
<span class="sd">        will have ``tree.interval.left`` &lt;= ``position`` &lt; ``tree.interval.right``.</span>
<span class="sd">        See also :meth:`Tree.seek`.</span>

<span class="sd">        :param float position: A genomic location.</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.at(2.5, sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A new instance of :class:`Tree` positioned to cover the specified</span>
<span class="sd">            genomic location.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="TreeSequence.at_index"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.at_index">[docs]</a>    <span class="k">def</span> <span class="nf">at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree at the specified index. See also :meth:`Tree.seek_index`.</span>

<span class="sd">        :param int index: The index of the required tree.</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.at_index(4, sample_lists=True)``</span>
<span class="sd">            will result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A new instance of :class:`Tree` positioned at the specified index.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">seek_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="TreeSequence.first"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first tree in this :class:`TreeSequence`. To iterate over all</span>
<span class="sd">        trees in the sequence, use the :meth:`.trees` method.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.first(sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: The first tree in this tree sequence.</span>
<span class="sd">        :rtype: :class:`Tree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="TreeSequence.last"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the last tree in this :class:`TreeSequence`. To iterate over all</span>
<span class="sd">        trees in the sequence, use the :meth:`.trees` method.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.first(sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: The last tree in this tree sequence.</span>
<span class="sd">        :rtype: :class:`Tree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">last</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="TreeSequence.trees"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trees">[docs]</a>    <span class="k">def</span> <span class="nf">trees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tracked_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_lists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">root_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">sample_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tracked_leaves</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">leaf_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">leaf_lists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the trees in this tree sequence. Each value</span>
<span class="sd">        returned in this iterator is an instance of :class:`Tree`. Upon</span>
<span class="sd">        successful termination of the iterator, the tree will be in the</span>
<span class="sd">        &quot;cleared&quot; null state.</span>

<span class="sd">        The ``sample_lists`` and ``tracked_samples`` parameters are passed</span>
<span class="sd">        to the :class:`Tree` constructor, and control</span>
<span class="sd">        the options that are set in the returned tree instance.</span>

<span class="sd">        :warning: Do not store the results of this iterator in a list!</span>
<span class="sd">           For performance reasons, the same underlying object is used</span>
<span class="sd">           for every tree returned which will most likely lead to unexpected</span>
<span class="sd">           behaviour. If you wish to obtain a list of trees in a tree sequence</span>
<span class="sd">           please use ``ts.aslist()`` instead.</span>

<span class="sd">        :param list tracked_samples: The list of samples to be tracked and</span>
<span class="sd">            counted using the :meth:`Tree.num_tracked_samples` method.</span>
<span class="sd">        :param bool sample_lists: If True, provide more efficient access</span>
<span class="sd">            to the samples beneath a give node using the</span>
<span class="sd">            :meth:`Tree.samples` method.</span>
<span class="sd">        :param int root_threshold: The minimum number of samples that a node</span>
<span class="sd">            must be ancestral to for it to be in the list of roots. By default</span>
<span class="sd">            this is 1, so that isolated samples (representing missing data)</span>
<span class="sd">            are roots. To efficiently restrict the roots of the tree to</span>
<span class="sd">            those subtending meaningful topology, set this to 2. This value</span>
<span class="sd">            is only relevant when trees have multiple roots.</span>
<span class="sd">        :param bool sample_counts: Deprecated since 0.2.4.</span>
<span class="sd">        :return: An iterator over the Trees in this tree sequence.</span>
<span class="sd">        :rtype: collections.abc.Iterable, :class:`Tree`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># tracked_leaves, leaf_counts and leaf_lists are deprecated aliases</span>
        <span class="c1"># for tracked_samples, sample_counts and sample_lists respectively.</span>
        <span class="c1"># These are left over from an older version of the API when leaves</span>
        <span class="c1"># and samples were synonymous.</span>
        <span class="k">if</span> <span class="n">tracked_leaves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tracked_samples</span> <span class="o">=</span> <span class="n">tracked_leaves</span>
        <span class="k">if</span> <span class="n">leaf_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_counts</span> <span class="o">=</span> <span class="n">leaf_counts</span>
        <span class="k">if</span> <span class="n">leaf_lists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_lists</span> <span class="o">=</span> <span class="n">leaf_lists</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tracked_samples</span><span class="o">=</span><span class="n">tracked_samples</span><span class="p">,</span>
            <span class="n">sample_lists</span><span class="o">=</span><span class="n">sample_lists</span><span class="p">,</span>
            <span class="n">root_threshold</span><span class="o">=</span><span class="n">root_threshold</span><span class="p">,</span>
            <span class="n">sample_counts</span><span class="o">=</span><span class="n">sample_counts</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeIterator</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.coiterate"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.coiterate">[docs]</a>    <span class="k">def</span> <span class="nf">coiterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the pairs of trees for each distinct</span>
<span class="sd">        interval in the specified pair of tree sequences.</span>

<span class="sd">        :param TreeSequence other: The other tree sequence from which to take trees. The</span>
<span class="sd">            sequence length must be the same as the current tree sequence.</span>
<span class="sd">        :param \\**kwargs: Further named arguments that will be passed to the</span>
<span class="sd">            :meth:`.trees` method when constructing the returned trees.</span>

<span class="sd">        :return: An iterator returning successive tuples of the form</span>
<span class="sd">            ``(interval, tree_self, tree_other)``. For example, the first item returned</span>
<span class="sd">            will consist of an tuple of the initial interval, the first tree of the</span>
<span class="sd">            current tree sequence, and the first tree of the ``other`` tree sequence;</span>
<span class="sd">            the ``.left`` attribute of the initial interval will be 0 and the ``.right``</span>
<span class="sd">            attribute will be the smallest non-zero breakpoint of the 2 tree sequences.</span>
<span class="sd">        :rtype: iter(:class:`Interval`, :class:`Tree`, :class:`Tree`)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tree sequences must be of equal sequence length.&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">trees1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">trees2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees1</span><span class="p">)</span>
        <span class="n">tree2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees2</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tree1</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree2</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span>
            <span class="c1"># Advance</span>
            <span class="k">if</span> <span class="n">tree1</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">tree1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree2</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">tree2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.haplotypes"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.haplotypes">[docs]</a>    <span class="k">def</span> <span class="nf">haplotypes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the strings of haplotypes that result from</span>
<span class="sd">        the trees and mutations in this tree sequence. Each haplotype string</span>
<span class="sd">        is guaranteed to be of the same length. A tree sequence with</span>
<span class="sd">        :math:`n` samples and :math:`s` sites will return a total of :math:`n`</span>
<span class="sd">        strings of :math:`s` alleles concatenated together, where an allele</span>
<span class="sd">        consists of a single ascii character (tree sequences that include alleles</span>
<span class="sd">        which are not a single character in length, or where the character is</span>
<span class="sd">        non-ascii, will raise an error). The first string returned is the</span>
<span class="sd">        haplotype for sample ``0``, and so on.</span>

<span class="sd">        The alleles at each site must be represented by single byte characters,</span>
<span class="sd">        (i.e. variants must be single nucleotide polymorphisms, or SNPs), hence</span>
<span class="sd">        the strings returned will all be of length :math:`s`, and for a haplotype</span>
<span class="sd">        ``h``, the value of ``h[j]`` will be the observed allelic state</span>
<span class="sd">        at site ``j``.</span>

<span class="sd">        If ``isolated_as_missing`` is True (the default), isolated samples without</span>
<span class="sd">        mutations directly above them will be treated as</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;` and will be</span>
<span class="sd">        represented in the string by the ``missing_data_character``. If</span>
<span class="sd">        instead it is set to False, missing data will be assigned the ancestral state</span>
<span class="sd">        (unless they have mutations directly above them, in which case they will take</span>
<span class="sd">        the most recent derived mutational state for that node). This was the default</span>
<span class="sd">        behaviour in versions prior to 0.2.0. Prior to 0.3.0 the `impute_missing_data`</span>
<span class="sd">        argument controlled this behaviour.</span>

<span class="sd">        See also the :meth:`.variants` iterator for site-centric access</span>
<span class="sd">        to sample genotypes.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            For large datasets, this method can consume a **very large** amount of</span>
<span class="sd">            memory! To output all the sample data, it is more efficient to iterate</span>
<span class="sd">            over sites rather than over samples. If you have a large dataset but only</span>
<span class="sd">            want to output the haplotypes for a subset of samples, it may be worth</span>
<span class="sd">            calling :meth:`.simplify` to reduce tree sequence down to the required</span>
<span class="sd">            samples before outputting haplotypes.</span>

<span class="sd">        :return: An iterator over the haplotype strings for the samples in</span>
<span class="sd">            this tree sequence.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the allele assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is</span>
<span class="sd">            the ``missing_data_character``. If False,</span>
<span class="sd">            missing samples will be assigned the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param str missing_data_character: A single ascii character that will</span>
<span class="sd">            be used to represent missing data.</span>
<span class="sd">            If any normal allele contains this character, an error is raised.</span>
<span class="sd">            Default: &#39;-&#39;.</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        :raises: TypeError if the ``missing_data_character`` or any of the alleles</span>
<span class="sd">            at a site or the are not a single ascii character.</span>
<span class="sd">        :raises: ValueError</span>
<span class="sd">            if the ``missing_data_character`` exists in one of the alleles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">missing_int8</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">missing_data_character</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">):</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span> <span class="n">missing_int8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">allele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">alleles</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">allele</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Multi-letter allele or deletion detected at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ascii_allele</span> <span class="o">=</span> <span class="n">allele</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Non-ascii character in allele at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">allele_int8</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ascii_allele</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">allele_int8</span> <span class="o">==</span> <span class="n">missing_int8</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The missing data character &#39;</span><span class="si">{}</span><span class="s2">&#39; clashes with an &quot;</span>
                            <span class="s2">&quot;existing allele at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">missing_data_character</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">alleles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">allele_int8</span>
            <span class="n">H</span><span class="p">[:,</span> <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">genotypes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">H</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.variants"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.variants">[docs]</a>    <span class="k">def</span> <span class="nf">variants</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">as_bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the variants in this tree sequence. See the</span>
<span class="sd">        :class:`Variant` class for details on the fields of each returned</span>
<span class="sd">        object. The ``genotypes`` for the variants are numpy arrays,</span>
<span class="sd">        corresponding to indexes into the ``alleles`` attribute in the</span>
<span class="sd">        :class:`Variant` object. By default, the ``alleles`` for each</span>
<span class="sd">        site are generated automatically, such that the ancestral state</span>
<span class="sd">        is at the zeroth index and subsequent alleles are listed in no</span>
<span class="sd">        particular order. This means that the encoding of alleles in</span>
<span class="sd">        terms of genotype values can vary from site-to-site, which is</span>
<span class="sd">        sometimes inconvenient. It is possible to specify a fixed mapping</span>
<span class="sd">        from allele strings to genotype values using the ``alleles``</span>
<span class="sd">        parameter. For example, if we set ``alleles=(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;)``,</span>
<span class="sd">        this will map allele &quot;A&quot; to 0, &quot;C&quot; to 1 and so on (the</span>
<span class="sd">        :data:`ALLELES_ACGT` constant provides a shortcut for this</span>
<span class="sd">        common mapping).</span>

<span class="sd">        By default, genotypes are generated for all samples. The ``samples``</span>
<span class="sd">        parameter allows us to specify the nodes for which genotypes are</span>
<span class="sd">        generated; output order of genotypes in the returned variants</span>
<span class="sd">        corresponds to the order of the samples in this list. It is also</span>
<span class="sd">        possible to provide **non-sample** nodes as an argument here, if you</span>
<span class="sd">        wish to generate genotypes for (e.g.) internal nodes. However,</span>
<span class="sd">        ``isolated_as_missing`` must be False in this case, as it is not</span>
<span class="sd">        possible to detect missing data for non-sample nodes.</span>

<span class="sd">        If isolated samples are present at a given site without mutations above them,</span>
<span class="sd">        they will be interpreted as :ref:`missing data&lt;sec_data_model_missing_data&gt;`</span>
<span class="sd">        the genotypes array will contain a special value :data:`MISSING_DATA`</span>
<span class="sd">        (-1) to identify these missing samples, and the ``alleles`` tuple will</span>
<span class="sd">        end with the value ``None`` (note that this is true whether we specify</span>
<span class="sd">        a fixed mapping using the ``alleles`` parameter or not).</span>
<span class="sd">        See the :class:`Variant` class for more details on how missing data is</span>
<span class="sd">        reported.</span>

<span class="sd">        Such samples are treated as missing data by default, but if</span>
<span class="sd">        ``isolated_as_missing`` is set to to False, they will not be treated as</span>
<span class="sd">        missing, and so assigned the ancestral state.</span>
<span class="sd">        This was the default behaviour in versions prior to 0.2.0. Prior to 0.3.0</span>
<span class="sd">        the `impute_missing_data` argument controlled this behaviour.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The ``as_bytes`` parameter is kept as a compatibility</span>
<span class="sd">            option for older code. It is not the recommended way of</span>
<span class="sd">            accessing variant data, and will be deprecated in a later</span>
<span class="sd">            release.</span>

<span class="sd">        :param bool as_bytes: If True, the genotype values will be returned</span>
<span class="sd">            as a Python bytes object. Legacy use only.</span>
<span class="sd">        :param array_like samples: An array of sample IDs for which to generate</span>
<span class="sd">            genotypes, or None for all samples. Default: None.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the allele assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is</span>
<span class="sd">            the ``missing_data_character``. If False, missing samples will be</span>
<span class="sd">            assigned the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param tuple alleles: A tuple of strings defining the encoding of</span>
<span class="sd">            alleles as integer genotype values. At least one allele must be provided.</span>
<span class="sd">            If duplicate alleles are provided, output genotypes will always be</span>
<span class="sd">            encoded as the first occurance of the allele. If None (the default),</span>
<span class="sd">            the alleles are encoded as they are encountered during genotype</span>
<span class="sd">            generation.</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>
<span class="sd">        :return: An iterator of all variants this tree sequence.</span>
<span class="sd">        :rtype: iter(:class:`Variant`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>
        <span class="c1"># See comments for the Variant type for discussion on why the</span>
        <span class="c1"># present form was chosen.</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">VariantGenerator</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">site_id</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">,</span> <span class="n">alleles</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span><span class="p">(</span><span class="n">site_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">as_bytes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">alleles</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;as_bytes only supported for single-letter alleles&quot;</span>
                    <span class="p">)</span>
                <span class="n">bytes_genotypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">ord</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alleles</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">bytes_genotypes</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">genotypes</span><span class="p">]</span>
                <span class="n">genotypes</span> <span class="o">=</span> <span class="n">bytes_genotypes</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">Variant</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.genotype_matrix"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genotype_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">genotype_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an :math:`m \\times n` numpy array of the genotypes in this</span>
<span class="sd">        tree sequence, where :math:`m` is the number of sites and :math:`n`</span>
<span class="sd">        the number of samples. The genotypes are the indexes into the array</span>
<span class="sd">        of ``alleles``, as described for the :class:`Variant` class.</span>

<span class="sd">        If isolated samples are present at a given site without mutations above them,</span>
<span class="sd">        they will be interpreted as :ref:`missing data&lt;sec_data_model_missing_data&gt;`</span>
<span class="sd">        the genotypes array will contain a special value :data:`MISSING_DATA`</span>
<span class="sd">        (-1) to identify these missing samples.</span>

<span class="sd">        Such samples are treated as missing data by default, but if</span>
<span class="sd">        ``isolated_as_missing`` is set to to False, they will not be treated as missing,</span>
<span class="sd">        and so assigned the ancestral state. This was the default behaviour in</span>
<span class="sd">        versions prior to 0.2.0. Prior to 0.3.0 the `impute_missing_data`</span>
<span class="sd">        argument controlled this behaviour.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method can consume a **very large** amount of memory! If</span>
<span class="sd">            all genotypes are not needed at once, it is usually better to</span>
<span class="sd">            access them sequentially using the :meth:`.variants` iterator.</span>

<span class="sd">        :param bool isolated_as_missing: If True, the allele assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is</span>
<span class="sd">            the ``missing_data_character``. If False, missing samples will be</span>
<span class="sd">            assigned the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param tuple alleles: A tuple of strings describing the encoding of</span>
<span class="sd">            alleles to genotype values. At least one allele must be provided.</span>
<span class="sd">            If duplicate alleles are provided, output genotypes will always be</span>
<span class="sd">            encoded as the first occurance of the allele. If None (the default),</span>
<span class="sd">            the alleles are encoded as they are encountered during genotype</span>
<span class="sd">            generation.</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>

<span class="sd">        :return: The full matrix of genotypes.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_genotype_matrix</span><span class="p">(</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span> <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.individual"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.individual">[docs]</a>    <span class="k">def</span> <span class="nf">individual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`individual &lt;sec_individual_table_definition&gt;`</span>
<span class="sd">        in this tree sequence with the specified ID.</span>

<span class="sd">        :rtype: :class:`Individual`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flags</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_individual</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Individual</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">individual</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.node"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.node">[docs]</a>    <span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`node &lt;sec_node_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID.</span>

<span class="sd">        :rtype: :class:`Node`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">flags</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="p">,</span>
            <span class="n">individual</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
            <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.edge"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edge">[docs]</a>    <span class="k">def</span> <span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`edge &lt;sec_edge_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID.</span>

<span class="sd">        :rtype: :class:`Edge`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.migration"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.migration">[docs]</a>    <span class="k">def</span> <span class="nf">migration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`migration &lt;sec_migration_table_definition&gt;` in this tree</span>
<span class="sd">        sequence with the specified ID.</span>

<span class="sd">        :rtype: :class:`.Migration`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_migration</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Migration</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">migration</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.mutation"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mutation">[docs]</a>    <span class="k">def</span> <span class="nf">mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`mutation &lt;sec_mutation_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID.</span>

<span class="sd">        :rtype: :class:`Mutation`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_mutation</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Mutation</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">mutation</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.site"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.site">[docs]</a>    <span class="k">def</span> <span class="nf">site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`site &lt;sec_site_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID.</span>

<span class="sd">        :rtype: :class:`Site`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_site</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">ll_mutations</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">ll_site</span>
        <span class="n">mutations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutation</span><span class="p">(</span><span class="n">mut_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">mut_id</span> <span class="ow">in</span> <span class="n">ll_mutations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Site</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
            <span class="n">mutations</span><span class="o">=</span><span class="n">mutations</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.population"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.population">[docs]</a>    <span class="k">def</span> <span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`population &lt;sec_population_table_definition&gt;`</span>
<span class="sd">        in this tree sequence with the specified ID.</span>

<span class="sd">        :rtype: :class:`Population`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">metadata</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_population</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Population</span><span class="p">(</span>
            <span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">encoded_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_provenance</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Provenance</span><span class="p">(</span><span class="n">id_</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">record</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for samples()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population_id</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.samples"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.samples">[docs]</a>    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array of the sample node IDs in this tree sequence. If the</span>
<span class="sd">        ``population`` parameter is specified, only return sample IDs from this</span>
<span class="sd">        population.</span>

<span class="sd">        :param int population: The population of interest. If None,</span>
<span class="sd">            return all samples.</span>
<span class="sd">        :param int population_id: Deprecated alias for ``population``.</span>
<span class="sd">        :return: A numpy array of the node IDs for the samples of interest.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;population_id and population are aliases. Cannot specify both&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population_id</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_samples</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">population</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_population</span> <span class="o">==</span> <span class="n">population</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">samples</span></div>

    <span class="k">def</span> <span class="nf">write_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">sequence_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrap_width</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
        <span class="s2">&quot;&quot;</span>
        <span class="c1"># suppress fasta visibility pending https://github.com/tskit-dev/tskit/issues/353</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes haplotype data for samples in FASTA format to the</span>
<span class="sd">        specified file-like object.</span>

<span class="sd">        Default `sequence_ids` (i.e. the text immediately following &quot;&gt;&quot;) are</span>
<span class="sd">        &quot;tsk_{sample_number}&quot; e.g. &quot;tsk_0&quot;, &quot;tsk_1&quot; etc. They can be set by providing</span>
<span class="sd">        a list of strings to the `sequence_ids` argument, which must equal the length</span>
<span class="sd">        of the number of samples. Please ensure that these are unique and compatible with</span>
<span class="sd">        fasta standards, since we do not check this.</span>
<span class="sd">        Default `wrap_width` for sequences is 60 characters in accordance with fasta</span>
<span class="sd">        standard outputs, but this can be specified. In order to avoid any line-wrapping</span>
<span class="sd">        of sequences, set `wrap_width = 0`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            with open(&quot;output.fasta&quot;, &quot;w&quot;) as fasta_file:</span>
<span class="sd">                ts.write_fasta(fasta_file)</span>

<span class="sd">        This can also be achieved on the command line use the ``tskit fasta`` command,</span>
<span class="sd">        e.g.:</span>

<span class="sd">        .. code-block:: bash</span>

<span class="sd">            $ tskit fasta example.trees &gt; example.fasta</span>

<span class="sd">        :param io.IOBase output: The file-like object to write the fasta output.</span>
<span class="sd">        :param list(str) sequence_ids: A list of string names to uniquely identify</span>
<span class="sd">            each of the sequences in the fasta file. If specified, this must be a</span>
<span class="sd">            list of strings of length equal to the number of samples which are output.</span>
<span class="sd">            Note that we do not check the form of these strings in any way, so that it</span>
<span class="sd">            is possible to output bad fasta IDs (for example, by including spaces</span>
<span class="sd">            before the unique identifying part of the string).</span>
<span class="sd">            The default is to output ``tsk_j`` for the jth individual.</span>
<span class="sd">        :param int wrap_width: This parameter specifies the number of sequence</span>
<span class="sd">            characters to include on each line in the fasta file, before wrapping</span>
<span class="sd">            to the next line for each sequence. Defaults to 60 characters in</span>
<span class="sd">            accordance with fasta standard outputs. To avoid any line-wrapping of</span>
<span class="sd">            sequences, set `wrap_width = 0`. Otherwise, supply any positive integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not specified, IDs default to sample index</span>
        <span class="k">if</span> <span class="n">sequence_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequence_ids</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tsk_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;sequence_ids must have length equal to the number of samples.&quot;</span>
            <span class="p">)</span>

        <span class="n">wrap_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">wrap_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrap_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;wrap_width must be a non-negative integer. &quot;</span>
                <span class="s2">&quot;You may specify `wrap_width=0` &quot;</span>
                <span class="s2">&quot;if you do not want any wrapping.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">hap</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">haplotypes</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">sequence_ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wrap_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hap</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hap_wrap</span> <span class="ow">in</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">hap</span><span class="p">,</span> <span class="n">wrap_width</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">hap_wrap</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.write_vcf"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.write_vcf">[docs]</a>    <span class="k">def</span> <span class="nf">write_vcf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">contig_id</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individual_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">position_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a VCF formatted file to the specified file-like object.</span>
<span class="sd">        If there is individual information present in the tree sequence</span>
<span class="sd">        (see :ref:`sec_individual_table_definition`), the values for</span>
<span class="sd">        sample nodes associated with these individuals are combined</span>
<span class="sd">        into phased multiploid individuals and output.</span>

<span class="sd">        If there is no individual data present in the tree sequence, synthetic</span>
<span class="sd">        individuals are created by combining adjacent samples, and the number</span>
<span class="sd">        of samples combined is equal to the specified ploidy value (1 by</span>
<span class="sd">        default). For example, if we have a ploidy of 2 and a sample of size 6,</span>
<span class="sd">        then we will have 3 diploid samples in the output, consisting of the</span>
<span class="sd">        combined genotypes for samples [0, 1], [2, 3] and [4, 5]. If we had</span>
<span class="sd">        genotypes 011110 at a particular variant, then we would output the</span>
<span class="sd">        diploid genotypes 0|1, 1|1 and 1|0 in VCF.</span>

<span class="sd">        Each individual in the output is identified by a string; these are the</span>
<span class="sd">        VCF &quot;sample&quot; names. By default, these are of the form ``tsk_0``,</span>
<span class="sd">        ``tsk_1`` etc, up to the number of individuals, but can be manually</span>
<span class="sd">        specified using the ``individual_names`` argument. We do not check</span>
<span class="sd">        for duplicates in this array, or perform any checks to ensure that</span>
<span class="sd">        the output VCF is well-formed.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Warning to ``plink`` users:</span>

<span class="sd">            As the default first individual name is ``tsk_0``, ``plink`` will</span>
<span class="sd">            throw this error when loading the VCF:</span>

<span class="sd">            ``Error: Sample ID ends with &quot;_0&quot;, which induces an invalid IID of &#39;0&#39;.``</span>

<span class="sd">            This can be fixed by using the ``individual_names`` argument</span>
<span class="sd">            to set the names to anything where the first name doesn&#39;t end with ``_0``.</span>
<span class="sd">            An example implementation for diploid individuals is:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                n_dip_indv = int(ts.num_samples / 2)</span>
<span class="sd">                indv_names = [f&quot;tsk_{str(i)}indv&quot; for i in range(n_dip_indv)]</span>
<span class="sd">                with open(&quot;output.vcf&quot;, &quot;w&quot;) as vcf_file:</span>
<span class="sd">                    ts.write_vcf(vcf_file, ploidy=2, individual_names=indv_names)</span>

<span class="sd">            Adding a second ``_`` (eg: ``tsk_0_indv``) is not recommended as</span>
<span class="sd">            ``plink`` uses ``_`` as the default separator for separating family</span>
<span class="sd">            id and individual id, and two ``_`` will throw an error.</span>


<span class="sd">        The REF value in the output VCF is the ancestral allele for a site</span>
<span class="sd">        and ALT values are the remaining alleles. It is important to note,</span>
<span class="sd">        therefore, that for real data this means that the REF value for a given</span>
<span class="sd">        site **may not** be equal to the reference allele. We also do not</span>
<span class="sd">        check that the alleles result in a valid VCF---for example, it is possible</span>
<span class="sd">        to use the tab character as an allele, leading to a broken VCF.</span>

<span class="sd">        The ``position_transform`` argument provides a way to flexibly translate</span>
<span class="sd">        the genomic location of sites in tskit to the appropriate value in VCF.</span>
<span class="sd">        There are two fundamental differences in the way that tskit and VCF define</span>
<span class="sd">        genomic coordinates. The first is that tskit uses floating point values</span>
<span class="sd">        to encode positions, whereas VCF uses integers. Thus, if the tree sequence</span>
<span class="sd">        contains positions at non-integral locations there is an information loss</span>
<span class="sd">        incurred by translating to VCF. By default, we round the site positions</span>
<span class="sd">        to the nearest integer, such that there may be several sites with the</span>
<span class="sd">        same integer position in the output. The second difference between VCF</span>
<span class="sd">        and tskit is that VCF is defined to be a 1-based coordinate system, whereas</span>
<span class="sd">        tskit uses 0-based. However, how coordinates are transformed depends</span>
<span class="sd">        on the VCF parser, and so we do **not** account for this change in</span>
<span class="sd">        coordinate system by default.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            with open(&quot;output.vcf&quot;, &quot;w&quot;) as vcf_file:</span>
<span class="sd">                tree_sequence.write_vcf(vcf_file, ploidy=2)</span>

<span class="sd">        The VCF output can also be compressed using the :mod:`gzip` module, if you wish:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import gzip</span>

<span class="sd">            with gzip.open(&quot;output.vcf.gz&quot;, &quot;wt&quot;) as f:</span>
<span class="sd">                ts.write_vcf(f)</span>

<span class="sd">        However, this gzipped VCF may not be fully compatible with downstream tools</span>
<span class="sd">        such as tabix, which may require the VCF use the specialised bgzip format.</span>
<span class="sd">        A general way to convert VCF data to various formats is to pipe the text</span>
<span class="sd">        produced by ``tskit`` into ``bcftools``, as done here:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import os</span>
<span class="sd">            import subprocess</span>

<span class="sd">            read_fd, write_fd = os.pipe()</span>
<span class="sd">            write_pipe = os.fdopen(write_fd, &quot;w&quot;)</span>
<span class="sd">            with open(&quot;output.bcf&quot;, &quot;w&quot;) as bcf_file:</span>
<span class="sd">                proc = subprocess.Popen(</span>
<span class="sd">                    [&quot;bcftools&quot;, &quot;view&quot;, &quot;-O&quot;, &quot;b&quot;], stdin=read_fd, stdout=bcf_file</span>
<span class="sd">                )</span>
<span class="sd">                ts.write_vcf(write_pipe)</span>
<span class="sd">                write_pipe.close()</span>
<span class="sd">                os.close(read_fd)</span>
<span class="sd">                proc.wait()</span>
<span class="sd">                if proc.returncode != 0:</span>
<span class="sd">                    raise RuntimeError(&quot;bcftools failed with status:&quot;, proc.returncode)</span>

<span class="sd">        This can also be achieved on the command line use the ``tskit vcf`` command,</span>
<span class="sd">        e.g.:</span>

<span class="sd">        .. code-block:: bash</span>

<span class="sd">            $ tskit vcf example.trees | bcftools view -O b &gt; example.bcf</span>

<span class="sd">        :param io.IOBase output: The file-like object to write the VCF output.</span>
<span class="sd">        :param int ploidy: The ploidy of the individuals to be written to</span>
<span class="sd">            VCF. This sample size must be evenly divisible by ploidy.</span>
<span class="sd">        :param str contig_id: The value of the CHROM column in the output VCF.</span>
<span class="sd">        :param list(int) individuals: A list containing the individual IDs to</span>
<span class="sd">            write out to VCF. Defaults to all individuals in the tree sequence.</span>
<span class="sd">        :param list(str) individual_names: A list of string names to identify</span>
<span class="sd">            individual columns in the VCF. In VCF nomenclature, these are the</span>
<span class="sd">            sample IDs. If specified, this must be a list of strings of</span>
<span class="sd">            length equal to the number of individuals to be output. Note that</span>
<span class="sd">            we do not check the form of these strings in any way, so that is</span>
<span class="sd">            is possible to output malformed VCF (for example, by embedding a</span>
<span class="sd">            tab character within on of the names). The default is to output</span>
<span class="sd">            ``tsk_j`` for the jth individual.</span>
<span class="sd">        :param position_transform: A callable that transforms the</span>
<span class="sd">            site position values into integer valued coordinates suitable for</span>
<span class="sd">            VCF. The function takes a single positional parameter x and must</span>
<span class="sd">            return an integer numpy array the same dimension as x. By default,</span>
<span class="sd">            this is set to ``numpy.round()`` which will round values to the</span>
<span class="sd">            nearest integer. If the string &quot;legacy&quot; is provided here, the</span>
<span class="sd">            pre 0.2.0 legacy behaviour of rounding values to the nearest integer</span>
<span class="sd">            (starting from 1) and avoiding the output of identical positions</span>
<span class="sd">            by incrementing is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">vcf</span><span class="o">.</span><span class="n">VcfWriter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">contig_id</span><span class="o">=</span><span class="n">contig_id</span><span class="p">,</span>
            <span class="n">individuals</span><span class="o">=</span><span class="n">individuals</span><span class="p">,</span>
            <span class="n">individual_names</span><span class="o">=</span><span class="n">individual_names</span><span class="p">,</span>
            <span class="n">position_transform</span><span class="o">=</span><span class="n">position_transform</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.to_nexus"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.to_nexus">[docs]</a>    <span class="k">def</span> <span class="nf">to_nexus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `nexus encoding &lt;https://en.wikipedia.org/wiki/Nexus_file&gt;`_</span>
<span class="sd">        of this tree sequence. Trees along the sequence are listed sequentially in</span>
<span class="sd">        the TREES block. The tree spanning the interval :math:`[x, y)`` is</span>
<span class="sd">        given the name &quot;tree_x_y&quot;. Spatial positions are written at the</span>
<span class="sd">        specified precision.</span>

<span class="sd">        Nodes in the tree sequence are identified by the taxon labels of the</span>
<span class="sd">        form ``f&quot;tsk_{node.id}_{node.flags}&quot;``, such that a node with ``id=5``</span>
<span class="sd">        and ``flags=1`` will have the label ``&quot;tsk_5_1&quot;`` (please see the</span>
<span class="sd">        :ref:`data model &lt;sec_node_table_definition&gt;` section for details</span>
<span class="sd">        on the interpretation of node ID and flags values). These labels are</span>
<span class="sd">        listed for all nodes in the tree sequence in the ``TAXLABELS`` block.</span>

<span class="sd">        :param int precision: The numerical precision with which branch lengths</span>
<span class="sd">            and tree positions are printed.</span>
<span class="sd">        :return: A nexus representation of this TreeSequence.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;tsk_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">flags</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;#NEXUS</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;BEGIN TAXA;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;TAXLABELS &quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_labels</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;END;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;BEGIN TREES;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
            <span class="n">start_interval</span> <span class="o">=</span> <span class="s2">&quot;{0:.</span><span class="si">{1}</span><span class="s2">f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
            <span class="n">end_interval</span> <span class="o">=</span> <span class="s2">&quot;{0:.</span><span class="si">{1}</span><span class="s2">f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
            <span class="n">newick</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">newick</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">TREE tree</span><span class="si">{</span><span class="n">start_interval</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">end_interval</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">newick</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;END;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="TreeSequence.to_macs"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.to_macs">[docs]</a>    <span class="k">def</span> <span class="nf">to_macs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a `macs encoding &lt;https://github.com/gchen98/macs&gt;`_</span>
<span class="sd">        of this tree sequence.</span>

<span class="sd">        :return: The macs representation of this TreeSequence as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample_size</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;COMMAND:</span><span class="se">\t</span><span class="s2">not_macs </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SEED:</span><span class="se">\t</span><span class="s2">ASEED&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">as_bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SITE:</span><span class="se">\t</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">position</span> <span class="o">/</span> <span class="n">m</span><span class="si">}</span><span class="se">\t</span><span class="s2">0.0</span><span class="se">\t</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="TreeSequence.simplify"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">map_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">keep_unary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_input_roots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_zero_mutation_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Deprecated alias for filter_sites</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simplified tree sequence that retains only the history of</span>
<span class="sd">        the nodes given in the list ``samples``. If ``map_nodes`` is true,</span>
<span class="sd">        also return a numpy array whose ``u``th element is the ID of the node</span>
<span class="sd">        in the simplified tree sequence that corresponds to node ``u`` in the</span>
<span class="sd">        original tree sequence, or :data:`tskit.NULL` (-1) if ``u`` is no longer</span>
<span class="sd">        present in the simplified tree sequence.</span>

<span class="sd">        In the returned tree sequence, the node with ID ``0`` corresponds to</span>
<span class="sd">        ``samples[0]``, node ``1`` corresponds to ``samples[1]``, and so on.</span>
<span class="sd">        Besides the samples, node IDs in the returned tree sequence are then</span>
<span class="sd">        allocated sequentially in time order.</span>

<span class="sd">        If you wish to simplify a set of tables that do not satisfy all</span>
<span class="sd">        requirements for building a TreeSequence, then use</span>
<span class="sd">        :meth:`TableCollection.simplify`.</span>

<span class="sd">        If the ``reduce_to_site_topology`` parameter is True, the returned tree</span>
<span class="sd">        sequence will contain only topological information that is necessary to</span>
<span class="sd">        represent the trees that contain sites. If there are zero sites in this</span>
<span class="sd">        tree sequence, this will result in an output tree sequence with zero edges.</span>
<span class="sd">        When the number of sites is greater than zero, every tree in the output</span>
<span class="sd">        tree sequence will contain at least one site. For a given site, the</span>
<span class="sd">        topology of the tree containing that site will be identical</span>
<span class="sd">        (up to node ID remapping) to the topology of the corresponding tree</span>
<span class="sd">        in the input tree sequence.</span>

<span class="sd">        If ``filter_populations``, ``filter_individuals`` or ``filter_sites`` is</span>
<span class="sd">        True, any of the corresponding objects that are not referenced elsewhere</span>
<span class="sd">        are filtered out. As this is the default behaviour, it is important to</span>
<span class="sd">        realise IDs for these objects may change through simplification. By setting</span>
<span class="sd">        these parameters to False, however, the corresponding tables can be preserved</span>
<span class="sd">        without changes.</span>

<span class="sd">        :param list samples: The list of nodes for which to retain information. This</span>
<span class="sd">            may be a numpy array (or array-like) object (dtype=np.int32).</span>
<span class="sd">        :param bool map_nodes: If True, return a tuple containing the resulting</span>
<span class="sd">            tree sequence and a numpy array mapping node IDs in the current tree</span>
<span class="sd">            sequence to their corresponding node IDs in the returned tree sequence.</span>
<span class="sd">            If False (the default), return only the tree sequence object itself.</span>
<span class="sd">        :param bool reduce_to_site_topology: Whether to reduce the topology down</span>
<span class="sd">            to the trees that are present at sites. (Default: False)</span>
<span class="sd">        :param bool filter_populations: If True, remove any populations that are</span>
<span class="sd">            not referenced by nodes after simplification; new population IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the population table will</span>
<span class="sd">            not be altered in any way. (Default: True)</span>
<span class="sd">        :param bool filter_individuals: If True, remove any individuals that are</span>
<span class="sd">            not referenced by nodes after simplification; new individual IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the individual table will</span>
<span class="sd">            not be altered in any way. (Default: True)</span>
<span class="sd">        :param bool filter_sites: If True, remove any sites that are</span>
<span class="sd">            not referenced by mutations after simplification; new site IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the site table will not</span>
<span class="sd">            be altered in any way. (Default: True)</span>
<span class="sd">        :param bool keep_unary: If True, any unary nodes (i.e. nodes with exactly</span>
<span class="sd">            one child) that exist on the path from samples to root will be preserved</span>
<span class="sd">            in the output. (Default: False)</span>
<span class="sd">        :param bool keep_input_roots: If True, insert edges from the MRCAs of the</span>
<span class="sd">            samples to the roots in the input trees. If False, no topology older</span>
<span class="sd">            than the MRCAs of the samples will be included. (Default: False)</span>
<span class="sd">        :param bool record_provenance: If True, record details of this call to</span>
<span class="sd">            simplify in the returned tree sequence&#39;s provenance information</span>
<span class="sd">            (Default: True).</span>
<span class="sd">        :param bool filter_zero_mutation_sites: Deprecated alias for ``filter_sites``.</span>
<span class="sd">        :return: The simplified tree sequence, or (if ``map_nodes`` is True)</span>
<span class="sd">            a tuple consisting of the simplified tree sequence and a numpy array</span>
<span class="sd">            mapping source node IDs to their corresponding IDs in the new tree</span>
<span class="sd">            sequence.</span>
<span class="sd">        :rtype: .TreeSequence or (.TreeSequence, numpy.ndarray)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_samples</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="n">reduce_to_site_topology</span><span class="p">,</span>
            <span class="n">filter_populations</span><span class="o">=</span><span class="n">filter_populations</span><span class="p">,</span>
            <span class="n">filter_individuals</span><span class="o">=</span><span class="n">filter_individuals</span><span class="p">,</span>
            <span class="n">filter_sites</span><span class="o">=</span><span class="n">filter_sites</span><span class="p">,</span>
            <span class="n">keep_unary</span><span class="o">=</span><span class="n">keep_unary</span><span class="p">,</span>
            <span class="n">keep_input_roots</span><span class="o">=</span><span class="n">keep_input_roots</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">filter_zero_mutation_sites</span><span class="o">=</span><span class="n">filter_zero_mutation_sites</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">if</span> <span class="n">map_nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_ts</span><span class="p">,</span> <span class="n">node_map</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_ts</span></div>

<div class="viewcode-block" id="TreeSequence.delete_sites"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.delete_sites">[docs]</a>    <span class="k">def</span> <span class="nf">delete_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_ids</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with the specified sites (and their</span>
<span class="sd">        associated mutations) entirely removed. The site IDs do not need to be in any</span>
<span class="sd">        particular order, and specifying the same ID multiple times does not have any</span>
<span class="sd">        effect (i.e., calling ``tree_sequence.delete_sites([0, 1, 1])`` has the same</span>
<span class="sd">        effect as calling ``tree_sequence.delete_sites([0, 1])``.</span>

<span class="sd">        :param list[int] site_ids: A list of site IDs specifying the sites to remove.</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">delete_sites</span><span class="p">(</span><span class="n">site_ids</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.delete_intervals"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.delete_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">delete_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence for which information in the</span>
<span class="sd">        specified list of genomic intervals has been deleted. Edges spanning these</span>
<span class="sd">        intervals are truncated or deleted, and sites and mutations falling within</span>
<span class="sd">        them are discarded. Note that it is the information in the intervals that</span>
<span class="sd">        is deleted, not the intervals themselves, so in particular, all samples</span>
<span class="sd">        will be isolated in the deleted intervals.</span>

<span class="sd">        Note that node IDs may change as a result of this operation,</span>
<span class="sd">        as by default :meth:`.simplify` is called on the returned tree sequence</span>
<span class="sd">        to remove redundant nodes. If you wish to map node IDs onto the same</span>
<span class="sd">        nodes before and after this method has been called, specify ``simplify=False``.</span>

<span class="sd">        See also :meth:`.keep_intervals`, :meth:`.ltrim`, :meth:`.rtrim`, and</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to delete. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, return a simplified tree sequence where nodes</span>
<span class="sd">            no longer used are discarded. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: ``True``).</span>
<span class="sd">        :rtype: .TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">delete_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.keep_intervals"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.keep_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">keep_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence which includes only information in</span>
<span class="sd">        the specified list of genomic intervals. Edges are truncated to lie within</span>
<span class="sd">        these intervals, and sites and mutations falling outside these intervals</span>
<span class="sd">        are discarded.  Note that it is the information outside the intervals that</span>
<span class="sd">        is deleted, not the intervals themselves, so in particular, all samples</span>
<span class="sd">        will be isolated outside of the retained intervals.</span>

<span class="sd">        Note that node IDs may change as a result of this operation,</span>
<span class="sd">        as by default :meth:`.simplify` is called on the returned tree sequence</span>
<span class="sd">        to remove redundant nodes. If you wish to map node IDs onto the same</span>
<span class="sd">        nodes before and after this method has been called, specify ``simplify=False``.</span>

<span class="sd">        See also :meth:`.keep_intervals`, :meth:`.ltrim`, :meth:`.rtrim`, and</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to keep. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, return a simplified tree sequence where nodes</span>
<span class="sd">            no longer used are discarded. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence.</span>
<span class="sd">            (Default: True).</span>
<span class="sd">        :rtype: .TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.ltrim"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.ltrim">[docs]</a>    <span class="k">def</span> <span class="nf">ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with a potentially changed coordinate</span>
<span class="sd">        system, such that empty regions (i.e. those not covered by any edge) at the start</span>
<span class="sd">        of the tree sequence are trimmed away, and the leftmost edge starts at position</span>
<span class="sd">        0. This affects the reported position of sites and edges. Additionally, sites and</span>
<span class="sd">        their associated mutations to the left of the new zero point are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.rtrim"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.rtrim">[docs]</a>    <span class="k">def</span> <span class="nf">rtrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with the ``sequence_length`` property reset</span>
<span class="sd">        so that the sequence ends at the end of the rightmost edge. Additionally, sites</span>
<span class="sd">        and their associated mutations at positions greater than the new</span>
<span class="sd">        ``sequence_length`` are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">rtrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.trim"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trim">[docs]</a>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with any empty regions (i.e. those not</span>
<span class="sd">        covered by any edge) on the right and left trimmed away. This may reset both the</span>
<span class="sd">        coordinate system and the ``sequence_length`` property. It is functionally</span>
<span class="sd">        equivalent to :meth:`.rtrim` followed by :meth:`.ltrim`. Sites and their</span>
<span class="sd">        associated mutations in the empty regions are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.subset"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tree sequence modified to contain only the entries referring to</span>
<span class="sd">        the provided list of nodes, with nodes reordered according to the order</span>
<span class="sd">        they appear in the ``nodes`` argument. Specifically, this subsets and reorders</span>
<span class="sd">        each of the tables as follows:</span>

<span class="sd">        1. Nodes: if in the list of nodes, and in the order provided.</span>
<span class="sd">        2. Individuals and Populations: if referred to by a retained node,</span>
<span class="sd">           and in the order first seen when traversing the list of retained nodes.</span>
<span class="sd">        3. Edges: if both parent and child are retained nodes.</span>
<span class="sd">        4. Mutations: if the mutation&#39;s node is a retained node.</span>
<span class="sd">        5. Sites: if any mutations remain at the site after removing mutations.</span>

<span class="sd">        Retained edges, mutations, and sites appear in the same</span>
<span class="sd">        order as in the original tables.</span>

<span class="sd">        If ``nodes`` is the entire list of nodes in the tables, then the</span>
<span class="sd">        resulting tables will be identical to the original tables, but with</span>
<span class="sd">        nodes (and individuals and populations) reordered.</span>

<span class="sd">        To instead subset the tables to a given portion of the *genome*, see</span>
<span class="sd">        :meth:`.keep_intervals`.</span>

<span class="sd">        **Note:** This is quite different from :meth:`.simplify`: the resulting</span>
<span class="sd">        tables contain only the nodes given, not ancestral ones as well, and</span>
<span class="sd">        does not simplify the relationships in any way.</span>

<span class="sd">        :param list nodes: The list of nodes for which to retain information. This</span>
<span class="sd">            may be a numpy array (or array-like) object (dtype=np.int32).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :rtype: .TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.union"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">node_mapping</span><span class="p">,</span>
        <span class="n">check_shared_equality</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">add_populations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an expanded tree sequence which contains the node-wise union of</span>
<span class="sd">        ``self`` and ``other``, obtained by adding the non-shared portions of</span>
<span class="sd">        ``other`` onto ``self``. The &quot;shared&quot; portions are specified using a</span>
<span class="sd">        map that specifies which nodes in ``other`` are equivalent to those in</span>
<span class="sd">        ``self``: the ``node_mapping`` argument should be an array of length</span>
<span class="sd">        equal to the number of nodes in ``other`` and whose entries are the ID</span>
<span class="sd">        of the matching node in ``self``, or ``tskit.NULL`` if there is no</span>
<span class="sd">        matching node. Those nodes in ``other`` that map to ``tskit.NULL`` will</span>
<span class="sd">        be added to ``self``, along with:</span>

<span class="sd">        1. Individuals whose nodes are new to ``self``.</span>
<span class="sd">        2. Edges whose parent or child are new to ``self``.</span>
<span class="sd">        3. Mutations whose nodes are new to ``self``.</span>
<span class="sd">        4. Sites which were not present in ``self``, if the site contains a newly</span>
<span class="sd">           added mutation.</span>

<span class="sd">        By default, populations of newly added nodes are assumed to be new</span>
<span class="sd">        populations, and added to the population table as well.</span>

<span class="sd">        Note that this operation also sorts the resulting tables, so the</span>
<span class="sd">        resulting tree sequence may not be equal to ``self`` even if nothing</span>
<span class="sd">        new was added (although it would differ only in ordering of the tables).</span>

<span class="sd">        :param TableCollection other: Another table collection.</span>
<span class="sd">        :param list node_mapping: An array of node IDs that relate nodes in</span>
<span class="sd">            ``other`` to nodes in ``self``.</span>
<span class="sd">        :param bool check_shared_equality: If True, the shared portions of the</span>
<span class="sd">            tree sequences will be checked for equality. It does so by</span>
<span class="sd">            subsetting both ``self`` and ``other`` on the equivalent nodes</span>
<span class="sd">            specified in ``node_mapping``, and then checking for equality of</span>
<span class="sd">            the subsets.</span>
<span class="sd">        :param bool add_populations: If True, nodes new to ``self`` will be</span>
<span class="sd">            assigned new population IDs.</span>
<span class="sd">        :param bool record_provenance: Whether to record a provenance entry</span>
<span class="sd">            in the provenance table for this operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">other_tables</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">other_tables</span><span class="p">,</span>
            <span class="n">node_mapping</span><span class="p">,</span>
            <span class="n">check_shared_equality</span><span class="o">=</span><span class="n">check_shared_equality</span><span class="p">,</span>
            <span class="n">add_populations</span><span class="o">=</span><span class="n">add_populations</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>

<div class="viewcode-block" id="TreeSequence.draw_svg"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.draw_svg">[docs]</a>    <span class="k">def</span> <span class="nf">draw_svg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">root_svg_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_root_branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an SVG representation of a tree sequence.</span>

<span class="sd">        When working in a Jupyter notebook, use the ``IPython.display.SVG`` function</span>
<span class="sd">        to display the SVG output from this function inline in the notebook::</span>

<span class="sd">            &gt;&gt;&gt; SVG(tree.draw_svg())</span>

<span class="sd">        The visual elements in the svg are</span>
<span class="sd">        `grouped &lt;https://www.w3.org/TR/SVG2/struct.html#Groups&gt;`_</span>
<span class="sd">        for easy styling and manipulation. The entire visualization with trees and X</span>
<span class="sd">        axis is contained within a group of class ``tree-sequence``. Each tree in</span>
<span class="sd">        the displayed tree sequence is contained in a group of class ``tree``, as</span>
<span class="sd">        described in :meth:`Tree.draw_svg`, so that visual elements pertaining to one</span>
<span class="sd">        or more trees targetted as documented in that method. For instance, the</span>
<span class="sd">        following style will change the colour of all the edges of the *initial*</span>
<span class="sd">        tree in the sequence and hide the non-sample node labels in *all* the trees</span>

<span class="sd">        .. code-block:: css</span>

<span class="sd">            .tree.t0 .edge {stroke: blue}</span>
<span class="sd">            .tree .node:not(.sample) &gt; text {visibility: hidden}</span>

<span class="sd">        See :meth:`Tree.draw_svg` for further details.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not write</span>
<span class="sd">            to file.</span>
<span class="sd">        :param size: A tuple of (width, height) giving the width and height of the</span>
<span class="sd">            produced SVG drawing in abstract user units (usually interpreted as pixels on</span>
<span class="sd">            display).</span>
<span class="sd">        :type size: tuple(int, int)</span>
<span class="sd">        :param str x_scale: Control how the X axis is drawn. If &quot;physical&quot; (the default)</span>
<span class="sd">            the axis scales linearly with physical distance along the sequence, and</span>
<span class="sd">            background shading is used to indicate the position of the trees along the</span>
<span class="sd">            sequence. If &quot;treewise&quot;, each axis tick corresponds to a tree boundary, which</span>
<span class="sd">            are positioned evenly along the axis, so that the X axis is of variable scale</span>
<span class="sd">            and no background scaling is required.</span>
<span class="sd">        :param str tree_height_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;``, node heights are proportional to their time</span>
<span class="sd">            values (this is the default). If this is equal to ``&quot;log_time&quot;``, node</span>
<span class="sd">            heights are proportional to their log(time) values. If it is equal to</span>
<span class="sd">            ``&quot;rank&quot;``, node heights are spaced equally according to their ranked times.</span>
<span class="sd">        :param node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            (specified by ID) that are present in this map; any nodes not present will</span>
<span class="sd">            not have a label.</span>
<span class="sd">        :type node_labels: dict(int, str)</span>
<span class="sd">        :param mutation_labels: If specified, show custom labels for the</span>
<span class="sd">            mutations (specified by ID) that are present in the map; any mutations</span>
<span class="sd">            not present will not have a label.</span>
<span class="sd">        :type mutation_labels: dict(int, str)</span>
<span class="sd">        :param dict root_svg_attributes: Additional attributes, such as an id, that will</span>
<span class="sd">            be embedded in the root ``&lt;svg&gt;`` tag of the generated drawing.</span>
<span class="sd">        :param str style: A `css string &lt;https://www.w3.org/TR/CSS21/syndata.htm&gt;`_</span>
<span class="sd">            that will be included in the ``&lt;style&gt;`` tag of the generated svg.</span>
<span class="sd">        :param str order: A string specifying the traversal type used to order the tips</span>
<span class="sd">            in each tree, as detailed in :meth:`Tree.nodes`. If None (default), use</span>
<span class="sd">            the default order as described in that method.</span>
<span class="sd">        :param bool force_root_branch: If ``True`` plot a branch (edge) above every tree</span>
<span class="sd">            root in the tree sequence. If ``None`` (default) then only plot such</span>
<span class="sd">            root branches if any root in the tree sequence has a mutation above it.</span>

<span class="sd">        :return: An SVG representation of a tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">SvgTreeSequence</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">x_scale</span><span class="o">=</span><span class="n">x_scale</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">root_svg_attributes</span><span class="o">=</span><span class="n">root_svg_attributes</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">force_root_branch</span><span class="o">=</span><span class="n">force_root_branch</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">drawing</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO remove the &#39;pretty&#39; when we are done debugging this.</span>
            <span class="n">draw</span><span class="o">.</span><span class="n">drawing</span><span class="o">.</span><span class="n">saveas</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="nf">draw_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO document this method.</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">drawing</span><span class="o">.</span><span class="n">TextTreeSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="c1">############################################</span>
    <span class="c1">#</span>
    <span class="c1"># Statistics computation</span>
    <span class="c1">#</span>
    <span class="c1">############################################</span>

<div class="viewcode-block" id="TreeSequence.general_stat"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.general_stat">[docs]</a>    <span class="k">def</span> <span class="nf">general_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">f</span><span class="p">,</span>
        <span class="n">output_dim</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a windowed statistic from weights and a summary function.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        On each tree, this</span>
<span class="sd">        propagates the weights ``W`` up the tree, so that the &quot;weight&quot; of each</span>
<span class="sd">        node is the sum of the weights of all samples at or below the node.</span>
<span class="sd">        Then the summary function ``f`` is applied to the weights, giving a</span>
<span class="sd">        summary for each node in each tree. How this is then aggregated depends</span>
<span class="sd">        on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Adds together the total summary value across all alleles in each window.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Adds together the summary value for each node, multiplied by the</span>
<span class="sd">            length of the branch above the node and the span of the tree.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            Returns each node&#39;s summary value added across trees and multiplied</span>
<span class="sd">            by the span of the tree.</span>

<span class="sd">        Both the weights and the summary can be multidimensional: if ``W`` has ``k``</span>
<span class="sd">        columns, and ``f`` takes a ``k``-vector and returns an ``m``-vector,</span>
<span class="sd">        then the output will be ``m``-dimensional for each node or window (depending</span>
<span class="sd">        on &quot;mode&quot;).</span>

<span class="sd">        .. note::</span>
<span class="sd">            The summary function ``f`` should return zero when given both 0 and</span>
<span class="sd">            the total weight (i.e., ``f(0) = 0`` and ``f(np.sum(W, axis=0)) = 0``),</span>
<span class="sd">            unless ``strict=False``.  This is necessary for the statistic to be</span>
<span class="sd">            unaffected by parts of the tree sequence ancestral to none or all</span>
<span class="sd">            of the samples, respectively.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each weight.</span>
<span class="sd">        :param f: A function that takes a one-dimensional array of length</span>
<span class="sd">            equal to the number of columns of ``W`` and returns a one-dimensional</span>
<span class="sd">            array.</span>
<span class="sd">        :param int output_dim: The length of ``f``&#39;s return value.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool strict: Whether to check that f(0) and f(total weight) are zero.</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;site&quot;</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">total_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">total_weights</span><span class="p">,</span> <span class="n">total_weights</span> <span class="o">*</span> <span class="mf">0.0</span><span class="p">]:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">fx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fx</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">output_dim</span><span class="p">,))):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Summary function does not return zero for both &quot;</span>
                        <span class="s2">&quot;zero weight and total weight.&quot;</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">general_stat</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.sample_count_stat"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.sample_count_stat">[docs]</a>    <span class="k">def</span> <span class="nf">sample_count_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">f</span><span class="p">,</span>
        <span class="n">output_dim</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a windowed statistic from sample counts and a summary function.</span>
<span class="sd">        This is a wrapper around :meth:`.general_stat` for the common case in</span>
<span class="sd">        which the weights are all either 1 or 0, i.e., functions of the joint</span>
<span class="sd">        allele frequency spectrum.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`sample sets &lt;sec_stats_sample_sets&gt;`,</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        If ``sample_sets`` is a list of ``k`` sets of samples, then</span>
<span class="sd">        ``f`` should be a function that takes an argument of length ``k`` and</span>
<span class="sd">        returns a one-dimensional array. The ``j``-th element of the argument</span>
<span class="sd">        to ``f`` will be the number of samples in ``sample_sets[j]`` that lie</span>
<span class="sd">        below the node that ``f`` is being evaluated for. See</span>
<span class="sd">        :meth:`.general_stat`  for more details.</span>

<span class="sd">        Here is a contrived example: suppose that ``A`` and ``B`` are two sets</span>
<span class="sd">        of samples with ``nA`` and ``nB`` elements, respectively. Passing these</span>
<span class="sd">        as sample sets will give ``f`` an argument of length two, giving the number</span>
<span class="sd">        of samples in ``A`` and ``B`` below the node in question. So, if we define</span>


<span class="sd">        .. code-block:: python</span>

<span class="sd">            def f(x):</span>
<span class="sd">                pA = x[0] / nA</span>
<span class="sd">                pB = x[1] / nB</span>
<span class="sd">                return np.array([pA * pB])</span>

<span class="sd">        then if all sites are biallelic,</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ts.sample_count_stat([A, B], f, windows=&quot;site&quot;, polarised=False, mode=&quot;site&quot;)</span>

<span class="sd">        would compute, for each site, the product of the derived allele</span>
<span class="sd">        frequencies in the two sample sets, in a (num sites, 1) array.  If</span>
<span class="sd">        instead ``f`` returns ``np.array([pA, pB, pA * pB])``, then the</span>
<span class="sd">        output would be a (num sites, 3) array, with the first two columns</span>
<span class="sd">        giving the allele frequencies in ``A`` and ``B``, respectively.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The summary function ``f`` should return zero when given both 0 and</span>
<span class="sd">            the sample size (i.e., ``f(0) = 0`` and</span>
<span class="sd">            ``f(np.array([len(x) for x in sample_sets]) = 0``).  This is</span>
<span class="sd">            necessary for the statistic to be unaffected by parts of the tree</span>
<span class="sd">            sequence ancestral to none or all of the samples, respectively.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param f: A function that takes a one-dimensional array of length</span>
<span class="sd">            equal to the number of sample sets and returns a one-dimensional array.</span>
<span class="sd">        :param int output_dim: The length of ``f``&#39;s return value.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool strict: Whether to check that f(0) and f(total weight) are zero.</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># helper function for common case where weights are indicators of sample sets</span>
        <span class="k">for</span> <span class="n">U</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">U</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Elements of sample_sets must be lists without repeated elements.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elements of sample_sets cannot be empty.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">is_sample</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not all elements of sample_sets are samples.&quot;</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">general_stat</span><span class="p">(</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">parse_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">):</span>
        <span class="c1"># Note: need to make sure windows is a string or we try to compare the</span>
        <span class="c1"># target with a numpy array elementwise.</span>
        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">windows</span> <span class="o">==</span> <span class="s2">&quot;trees&quot;</span><span class="p">:</span>
                <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoints</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">windows</span> <span class="o">==</span> <span class="s2">&quot;sites&quot;</span><span class="p">:</span>
                <span class="c1"># breakpoints are at 0.0 and at the sites and at the end</span>
                <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unrecognized window specification </span><span class="si">{</span><span class="n">windows</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;the only allowed strings are &#39;sites&#39; or &#39;trees&#39;&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__run_windowed_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">strip_dim</span> <span class="o">=</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_dim</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span> <span class="nf">__one_way_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>

        <span class="c1"># First try to convert to a 1D numpy array. If it is, then we strip off</span>
        <span class="c1"># the corresponding dimension from the output.</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;ve successfully converted sample_sets to a 1D numpy array</span>
            <span class="c1"># of integers then drop the dimension</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_sets</span><span class="p">]</span>
                <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>

        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">ll_method</span><span class="p">,</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span> <span class="nf">__k_way_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are not exactly </span><span class="si">{}</span><span class="s2"> sample &quot;</span>
                    <span class="s2">&quot;sets.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Indexes must be convertable to a 2D numpy array with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;columns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">ll_method</span><span class="p">,</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="c1">############################################</span>
    <span class="c1"># Statistics definitions</span>
    <span class="c1">############################################</span>

<div class="viewcode-block" id="TreeSequence.diversity"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.diversity">[docs]</a>    <span class="k">def</span> <span class="nf">diversity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mean genetic diversity (also knowns as &quot;Tajima&#39;s pi&quot;) in each of the</span>
<span class="sd">        sets of nodes from ``sample_sets``.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        Note that this quantity can also be computed by the</span>
<span class="sd">        :meth:`divergence &lt;.TreeSequence.divergence&gt;` method.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Mean pairwise genetic diversity: the average across distinct,</span>
<span class="sd">            randomly chosen pairs of chromosomes, of the density of sites at</span>
<span class="sd">            which the two carry different alleles, per unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Mean distance in the tree: the average across distinct, randomly chosen pairs</span>
<span class="sd">            of chromsomes and locations in the window, of the mean distance in the tree</span>
<span class="sd">            between the two samples (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of genome on which the node is an ancestor to</span>
<span class="sd">            only one of a random pair from the sample set, averaged over choices of pair.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.divergence"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.divergence">[docs]</a>    <span class="k">def</span> <span class="nf">divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mean genetic divergence between (and within) pairs of</span>
<span class="sd">        sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        As a special case, an index ``(j, j)`` will compute the</span>
<span class="sd">        :meth:`diversity &lt;.TreeSequence.diversity&gt;` of ``sample_set[j]``.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Mean pairwise genetic divergence: the average across distinct,</span>
<span class="sd">            randomly chosen pairs of chromosomes (one from each sample set), of</span>
<span class="sd">            the density of sites at which the two carry different alleles, per</span>
<span class="sd">            unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Mean distance in the tree: the average across distinct, randomly</span>
<span class="sd">            chosen pairs of chromsomes (one from each sample set) and locations</span>
<span class="sd">            in the window, of the mean distance in the tree between the two</span>
<span class="sd">            samples (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of genome on which the node is an ancestor to</span>
<span class="sd">            only one of a random pair (one from each sample set), averaged over</span>
<span class="sd">            choices of pair.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="c1"># JK: commenting this out for now to get the other methods well tested.</span>
    <span class="c1"># Issue: https://github.com/tskit-dev/tskit/issues/201</span>
    <span class="c1"># def divergence_matrix(self, sample_sets, windows=None, mode=&quot;site&quot;):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Finds the mean divergence  between pairs of samples from each set of</span>
    <span class="c1">#     samples and in each window. Returns a numpy array indexed by (window,</span>
    <span class="c1">#     sample_set, sample_set).  Diagonal entries are corrected so that the</span>
    <span class="c1">#     value gives the mean divergence for *distinct* samples, but it is not</span>
    <span class="c1">#     checked whether the sample_sets are disjoint (so offdiagonals are not</span>
    <span class="c1">#     corrected).  For this reason, if an element of `sample_sets` has only</span>
    <span class="c1">#     one element, the corresponding diagonal will be NaN.</span>

    <span class="c1">#     The mean divergence between two samples is defined to be the mean: (as</span>
    <span class="c1">#     a TreeStat) length of all edges separating them in the tree, or (as a</span>
    <span class="c1">#     SiteStat) density of segregating sites, at a uniformly chosen position</span>
    <span class="c1">#     on the genome.</span>

    <span class="c1">#     :param list sample_sets: A list of sets of IDs of samples.</span>
    <span class="c1">#     :param iterable windows: The breakpoints of the windows (including start</span>
    <span class="c1">#         and end, so has one more entry than number of windows).</span>
    <span class="c1">#     :return: A list of the upper triangle of mean TMRCA values in row-major</span>
    <span class="c1">#         order, including the diagonal.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     ns = len(sample_sets)</span>
    <span class="c1">#     indexes = [(i, j) for i in range(ns) for j in range(i, ns)]</span>
    <span class="c1">#     x = self.divergence(sample_sets, indexes, windows, mode=mode)</span>
    <span class="c1">#     nw = len(windows) - 1</span>
    <span class="c1">#     A = np.ones((nw, ns, ns), dtype=float)</span>
    <span class="c1">#     for w in range(nw):</span>
    <span class="c1">#         k = 0</span>
    <span class="c1">#         for i in range(ns):</span>
    <span class="c1">#             for j in range(i, ns):</span>
    <span class="c1">#                 A[w, i, j] = A[w, j, i] = x[w][k]</span>
    <span class="c1">#                 k += 1</span>
    <span class="c1">#     return A</span>

<div class="viewcode-block" id="TreeSequence.genetic_relatedness"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genetic_relatedness">[docs]</a>    <span class="k">def</span> <span class="nf">genetic_relatedness</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">proportion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes genetic relatedness between (and within) pairs of</span>
<span class="sd">        sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        :ref:`polarised &lt;sec_stats_polarisation&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Number of pairwise allelic matches in the window between two</span>
<span class="sd">            sample sets relative to the rest of the sample sets. To be precise,</span>
<span class="sd">            let `m(u,v)` denote the total number of alleles shared between</span>
<span class="sd">            nodes `u` and `v`, and let `m(I,J)` be the sum of `m(u,v)` over all</span>
<span class="sd">            nodes `u` in sample set `I` and `v` in sample set `J`. Let `S` and</span>
<span class="sd">            `T` be independently chosen sample sets. Then, for sample sets `I`</span>
<span class="sd">            and `J`, this computes `E[m(I,J) - m(I,S) - m(J,T) + m(S,T)]`.</span>
<span class="sd">            This can also be seen as the covariance of a quantitative trait</span>
<span class="sd">            determined by additive contributions from the genomes in each</span>
<span class="sd">            sample set. Let each allele be associated with an effect drawn from</span>
<span class="sd">            a `N(0,1/2)` distribution, and let the trait value of a sample set</span>
<span class="sd">            be the sum of its allele effects. Then, this computes the covariance</span>
<span class="sd">            between the trait values of two sample sets. For example, to</span>
<span class="sd">            compute covariance between the traits of diploid individuals, each</span>
<span class="sd">            sample set would be the pair of genomes of each individual; if</span>
<span class="sd">            ``proportion=True``, this then corresponds to :math:`K_{c0}` in</span>
<span class="sd">            `Speed &amp; Balding (2014) &lt;https://www.nature.com/articles/nrg3821&gt;`_.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Total area of branches in the window ancestral to pairs of samples</span>
<span class="sd">            in two sample sets relative to the rest of the sample sets. To be</span>
<span class="sd">            precise, let `B(u,v)` denote the total area of all branches</span>
<span class="sd">            ancestral to nodes `u` and `v`, and let `B(I,J)` be the sum of</span>
<span class="sd">            `B(u,v)` over all nodes `u` in sample set `I` and `v` in sample set</span>
<span class="sd">            `J`. Let `S` and `T` be two independently chosen sample sets. Then</span>
<span class="sd">            for sample sets `I` and `J`, this computes</span>
<span class="sd">            `E[B(I,J) - B(I,S) - B(J,T) + B(S,T)]`.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of the window over which pairs of</span>
<span class="sd">            samples in two sample sets are descendants, relative to the rest of</span>
<span class="sd">            the sample sets. To be precise, for each node `n`, let `N(u,v)`</span>
<span class="sd">            denote the proportion of the window over which samples `u` and `v`</span>
<span class="sd">            are descendants of `n`, and let and let `N(I,J)` be the sum of</span>
<span class="sd">            `N(u,v)` over all nodes `u` in sample set `I` and `v` in sample set</span>
<span class="sd">            `J`. Let `S` and `T` be two independently chosen sample sets. Then</span>
<span class="sd">            for sample sets `I` and `J`, this computes</span>
<span class="sd">            `E[N(I,J) - N(I,S) - N(J,T) + N(S,T)]`.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool proportion: Whether to divide the result by</span>
<span class="sd">            :meth:`.segregating_sites`, called with the same ``windows`` and</span>
<span class="sd">            ``mode`` (defaults to True). Note that this counts sites</span>
<span class="sd">            that are segregating between *any* of the samples of *any* of the</span>
<span class="sd">            sample sets (rather than segregating between all of the samples of</span>
<span class="sd">            the tree sequence).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">proportion</span><span class="p">:</span>
            <span class="c1"># TODO this should be done in C also</span>
            <span class="n">all_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">u</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sample_sets</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">s</span><span class="p">})</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">(</span>
                <span class="n">sample_sets</span><span class="o">=</span><span class="n">all_samples</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genetic_relatedness</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span></div>

<div class="viewcode-block" id="TreeSequence.trait_covariance"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_covariance">[docs]</a>    <span class="k">def</span> <span class="nf">trait_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the mean squared covariances between each of the columns of ``W``</span>
<span class="sd">        (the &quot;phenotypes&quot;) and inheritance along the tree sequence.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        Concretely, if `g` is a binary vector that indicates inheritance from an allele,</span>
<span class="sd">        branch, or node and `w` is a column of W, normalised to have mean zero,</span>
<span class="sd">        then the covariance of `g` and `w` is :math:`\\sum_i g_i w_i`, the sum of the</span>
<span class="sd">        weights corresponding to entries of `g` that are `1`. Since weights sum to</span>
<span class="sd">        zero, this is also equal to the sum of weights whose entries of `g` are 0.</span>
<span class="sd">        So, :math:`cov(g,w)^2 = ((\\sum_i g_i w_i)^2 + (\\sum_i (1-g_i) w_i)^2)/2`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum of squared covariances between presence/absence of each allele and</span>
<span class="sd">            phenotypes, divided by length of the window (if ``span_normalise=True``).</span>
<span class="sd">            This is computed as sum_a (sum(w[a])^2 / 2), where</span>
<span class="sd">            w is a column of W with the average subtracted off,</span>
<span class="sd">            and w[a] is the sum of all entries of w corresponding to samples</span>
<span class="sd">            carrying allele &quot;a&quot;, and the first sum is over all alleles.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The sum of squared covariances between the split induced by each branch and</span>
<span class="sd">            phenotypes, multiplied by branch length, averaged across trees in</span>
<span class="sd">            the window. This is computed as above: a branch with total weight</span>
<span class="sd">            w[b] below b contributes (branch length) * w[b]^2 to the total</span>
<span class="sd">            value for a tree. (Since the sum of w is zero, the total weight</span>
<span class="sd">            below b and not below b are equal, canceling the factor of 2</span>
<span class="sd">            above.)</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared covariance between the property of</span>
<span class="sd">            inheriting from this node and phenotypes, computed as in &quot;branch&quot;.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_covariance</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.trait_correlation"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">trait_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the mean squared correlations between each of the columns of ``W``</span>
<span class="sd">        (the &quot;phenotypes&quot;) and inheritance along the tree sequence.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        This is computed as squared covariance in</span>
<span class="sd">        :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`,</span>
<span class="sd">        but divided by :math:`p (1-p)`, where `p` is the proportion of samples</span>
<span class="sd">        inheriting from the allele, branch, or node in question.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum of squared correlations between presence/absence of each allele and</span>
<span class="sd">            phenotypes, divided by length of the window (if ``span_normalise=True``).</span>
<span class="sd">            This is computed as the</span>
<span class="sd">            :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`</span>
<span class="sd">            divided by the variance of the relevant column of W</span>
<span class="sd">            and by ;math:`p * (1 - p)`, where :math:`p` is the allele frequency.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The sum of squared correlations between the split induced by each branch and</span>
<span class="sd">            phenotypes, multiplied by branch length, averaged across trees in</span>
<span class="sd">            the window. This is computed as the</span>
<span class="sd">            :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`,</span>
<span class="sd">            divided by the variance of the column of w</span>
<span class="sd">            and by :math:`p * (1 - p)`, where :math:`p` is the proportion of</span>
<span class="sd">            the samples lying below the branch.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared correlation between the property of</span>
<span class="sd">            inheriting from this node and phenotypes, computed as in &quot;branch&quot;.</span>

<span class="sd">        Note that above we divide by the **sample** variance, which for a</span>
<span class="sd">        vector x of length n is ``np.var(x) * n / (n-1)``.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;. Each column must have positive standard</span>
<span class="sd">            deviation.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="n">sds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Weight columns must have positive variance&quot;</span><span class="p">,</span> <span class="s2">&quot;to compute correlation.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_correlation</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.trait_regression"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_regression">[docs]</a>    <span class="k">def</span> <span class="nf">trait_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated synonym for</span>
<span class="sd">        :meth:`trait_linear_model &lt;.TreeSequence.trait_linear_model&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This is deprecated: please use trait_linear_model( ) instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trait_linear_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.trait_linear_model"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_linear_model">[docs]</a>    <span class="k">def</span> <span class="nf">trait_linear_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the relationship between trait and genotype after accounting for</span>
<span class="sd">        covariates.  Concretely, for each trait w (i.e., each column of W),</span>
<span class="sd">        this does a least-squares fit of the linear model :math:`w \\sim g + Z`,</span>
<span class="sd">        where :math:`g` is inheritance in the tree sequence (e.g., genotype)</span>
<span class="sd">        and the columns of :math:`Z` are covariates, and returns the squared</span>
<span class="sd">        coefficient of :math:`g` in this linear model.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        To do this, if `g` is a binary vector that indicates inheritance from an allele,</span>
<span class="sd">        branch, or node and `w` is a column of W, there are :math:`k` columns of</span>
<span class="sd">        :math:`Z`, and the :math:`k+2`-vector :math:`b` minimises</span>
<span class="sd">        :math:`\\sum_i (w_i - b_0 - b_1 g_i - b_2 z_{2,i} - ... b_{k+2} z_{k+2,i})^2`</span>
<span class="sd">        then this returns the number :math:`b_1^2`. If :math:`g` lies in the linear span</span>
<span class="sd">        of the columns of :math:`Z`, then :math:`b_1` is set to 0. To fit the</span>
<span class="sd">        linear model without covariates (only the intercept), set `Z = None`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Computes the sum of :math:`b_1^2/2` for each allele in the window,</span>
<span class="sd">            as above with :math:`g` indicating presence/absence of the allele,</span>
<span class="sd">            then divided by the length of the window if ``span_normalise=True``.</span>
<span class="sd">            (For biallelic loci, this number is the same for both alleles, and so summing</span>
<span class="sd">            over each cancels the factor of two.)</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The squared coefficient `b_1^2`, computed for the split induced by each</span>
<span class="sd">            branch (i.e., with :math:`g` indicating inheritance from that branch),</span>
<span class="sd">            multiplied by branch length and tree span, summed over all trees</span>
<span class="sd">            in the window, and divided by the length of the window if</span>
<span class="sd">            ``span_normalise=True``.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared coefficient `b_1^2`, computed for the property of</span>
<span class="sd">            inheriting from this node, as in &quot;branch&quot;.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;.</span>
<span class="sd">        :param numpy.ndarray Z: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;covariate&quot;, or `None`. Columns of `Z` must be linearly</span>
<span class="sd">            independent.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">Z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">tZ</span><span class="p">)</span> <span class="o">==</span> <span class="n">tZ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">tZ</span>
        <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;First dimension of Z must equal the number of samples.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix of covariates is computationally singular.&quot;</span><span class="p">)</span>
        <span class="c1"># numpy returns a lower-triangular cholesky</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_linear_model</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.segregating_sites"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.segregating_sites">[docs]</a>    <span class="k">def</span> <span class="nf">segregating_sites</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the density of segregating sites for each of the sets of nodes</span>
<span class="sd">        from ``sample_sets``, and related quantities.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. For a sample set ``A``, computes:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum over sites of the number of alleles found in ``A`` at each site</span>
<span class="sd">            minus one, per unit of chromosome length.</span>
<span class="sd">            If all sites have at most two alleles, this is the density of sites</span>
<span class="sd">            that are polymorphic in ``A``. To get the **number** of segregating minor</span>
<span class="sd">            alleles per window, pass ``span_normalise=False``.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The total length of all branches in the tree subtended by the samples in</span>
<span class="sd">            ``A``, averaged across the window.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            The proportion of the window on which the node is ancestral to some,</span>
<span class="sd">            but not all, of the samples in ``A``.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.allele_frequency_spectrum"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.allele_frequency_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">allele_frequency_spectrum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the allele frequency spectrum (AFS) in windows across the genome for</span>
<span class="sd">        with respect to the specified ``sample_sets``.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`sample sets &lt;sec_stats_sample_sets&gt;`,</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        :ref:`polarised &lt;sec_stats_polarisation&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        and see :ref:`sec_tutorial_afs` for examples of how to use this method.</span>

<span class="sd">        Similar to other windowed stats, the first dimension in the returned array</span>
<span class="sd">        corresponds to windows, such that ``result[i]`` is the AFS in the ith</span>
<span class="sd">        window. The AFS in each window is a k-dimensional numpy array, where k is</span>
<span class="sd">        the number of input sample sets, such that ``result[i, j0, j1, ...]`` is the</span>
<span class="sd">        value associated with frequency ``j0`` in ``sample_sets[0]``, ``j1`` in</span>
<span class="sd">        ``sample_sets[1]``, etc, in window ``i``. From here, we will assume that</span>
<span class="sd">        ``afs`` corresponds to the result in a single window, i.e.,</span>
<span class="sd">        ``afs = result[i]``.</span>

<span class="sd">        If a single sample set is specified, the allele frequency spectrum within</span>
<span class="sd">        this set is returned, such that ``afs[j]`` is the value associated with</span>
<span class="sd">        frequency ``j``. Thus, singletons are counted in ``afs[1]``, doubletons in</span>
<span class="sd">        ``afs[2]``, and so on. The zeroth entry counts alleles or branches not</span>
<span class="sd">        seen in the samples but that are polymorphic among the rest of the samples</span>
<span class="sd">        of the tree sequence; likewise, the last entry counts alleles fixed in</span>
<span class="sd">        the sample set but polymorphic in the entire set of samples. Please see</span>
<span class="sd">        the :ref:`sec_tutorial_afs_zeroth_entry` for an illustration.</span>

<span class="sd">        .. warning:: Please note that singletons are **not** counted in the initial</span>
<span class="sd">            entry in each AFS array (i.e., ``afs[0]``), but in ``afs[1]``.</span>

<span class="sd">        If ``sample_sets`` is None (the default), the allele frequency spectrum</span>
<span class="sd">        for all samples in the tree sequence is returned.</span>

<span class="sd">        If more than one sample set is specified, the **joint** allele frequency</span>
<span class="sd">        spectrum within windows is returned. For example, if we set</span>
<span class="sd">        ``sample_sets = [S0, S1]``, then afs[1, 2] counts the number of sites that</span>
<span class="sd">        are singletons within S0 and doubletons in S1. The dimensions of the</span>
<span class="sd">        output array will be ``[num_windows] + [1 + len(S) for S in sample_sets]``.</span>

<span class="sd">        If ``polarised`` is False (the default) the AFS will be *folded*, so that</span>
<span class="sd">        the counts do not depend on knowing which allele is ancestral. If folded,</span>
<span class="sd">        the frequency spectrum for a single sample set ``S`` has ``afs[j] = 0`` for</span>
<span class="sd">        all ``j &gt; len(S) / 2``, so that alleles at frequency ``j`` and ``len(S) - j``</span>
<span class="sd">        both add to the same entry. If there is more than one sample set, the</span>
<span class="sd">        returned array is &quot;lower triangular&quot; in a similar way. For more details,</span>
<span class="sd">        especially about handling of multiallelic sites, see :ref:`sec_stats_afs`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The number of alleles at a given frequency within the specified sample</span>
<span class="sd">            sets for each window, per unit of sequence length. To obtain the total</span>
<span class="sd">            number of alleles, set ``span_normalise`` to False.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The total length of branches in the trees subtended by subsets of the</span>
<span class="sd">            specified sample sets, per unit of sequence length. To obtain the</span>
<span class="sd">            total, set ``span_normalise`` to False.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            Not supported for this method (raises a ValueError).</span>

<span class="sd">        For example, suppose that `S0` is a list of 5 sample IDs, and `S1` is</span>
<span class="sd">        a list of 3 other sample IDs. Then `afs = ts.allele_frequency_spectrum([S0, S1],</span>
<span class="sd">        mode=&quot;site&quot;, span_normalise=False)` will be a 5x3 numpy array, and if</span>
<span class="sd">        there are six alleles that are present in only one sample of `S0` but</span>
<span class="sd">        two samples of `S1`, then `afs[1,2]` will be equal to 6.  Similarly,</span>
<span class="sd">        `branch_afs = ts.allele_frequency_spectrum([S0, S1], mode=&quot;branch&quot;,</span>
<span class="sd">        span_normalise=False)` will also be a 5x3 array, and `branch_afs[1,2]`</span>
<span class="sd">        will be the total area (i.e., length times span) of all branches that</span>
<span class="sd">        are above exactly one sample of `S0` and two samples of `S1`.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of samples to compute the joint allele frequency</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between windows</span>
<span class="sd">            along the genome.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A (k + 1) dimensional numpy array, where k is the number of sample</span>
<span class="sd">            sets specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO should we allow a single sample_set to be specified here as a 1D array?</span>
        <span class="c1"># This won&#39;t change the output dimensions like the other stats.</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">allele_frequency_spectrum</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.Tajimas_D"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Tajimas_D">[docs]</a>    <span class="k">def</span> <span class="nf">Tajimas_D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Tajima&#39;s D of sets of nodes from ``sample_sets`` in windows.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on ``k = 1`` sample sets at a</span>
<span class="sd">        time. For a sample set ``X`` of ``n`` nodes, if and ``T`` is the mean</span>
<span class="sd">        number of pairwise differing sites in ``X`` and ``S`` is the number of</span>
<span class="sd">        sites segregating in ``X`` (computed with :meth:`diversity</span>
<span class="sd">        &lt;.TreeSequence.diversity&gt;` and :meth:`segregating sites</span>
<span class="sd">        &lt;.TreeSequence.segregating_sites&gt;`, respectively, both not span</span>
<span class="sd">        normalised), then Tajima&#39;s D is</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            D = (T - S / h) / sqrt(a * S + (b / c) * S * (S - 1))</span>
<span class="sd">            h = 1 + 1 / 2 + ... + 1 / (n - 1)</span>
<span class="sd">            g = 1 + 1 / 2 ** 2 + ... + 1 / (n - 1) ** 2</span>
<span class="sd">            a = (n + 1) / (3 * (n - 1) * h) - 1 / h ** 2</span>
<span class="sd">            b = 2 * (n ** 2 + n + 3) / (9 * n * (n - 1)) - (n + 2) / (h * n) + g / h ** 2</span>
<span class="sd">            c = h ** 2 + g</span>

<span class="sd">        What is computed for diversity and divergence depends on ``mode``;</span>
<span class="sd">        see those functions for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO this should be done in C as we&#39;ll want to support this method there.</span>
        <span class="k">def</span> <span class="nf">tjd_func</span><span class="p">(</span><span class="n">sample_set_sizes</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">sample_set_sizes</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">))</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">n</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">n</span><span class="p">])</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">h</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">g</span> <span class="o">/</span> <span class="n">h</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">S</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="n">h</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">g</span><span class="p">))</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">D</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="n">tjd_func</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.Fst"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Fst">[docs]</a>    <span class="k">def</span> <span class="nf">Fst</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes &quot;windowed&quot; Fst between pairs of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        For sample sets ``X`` and ``Y``, if ``d(X, Y)`` is the</span>
<span class="sd">        :meth:`divergence &lt;.TreeSequence.divergence&gt;`</span>
<span class="sd">        between ``X`` and ``Y``, and ``d(X)`` is the</span>
<span class="sd">        :meth:`diversity &lt;.TreeSequence.diversity&gt;` of ``X``, then what is</span>
<span class="sd">        computed is</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            Fst = 1 - 2 * (d(X) + d(Y)) / (d(X) + 2 * d(X, Y) + d(Y))</span>

<span class="sd">        What is computed for diversity and divergence depends on ``mode``;</span>
<span class="sd">        see those functions for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO this should really be implemented in C (presumably C programmers will want</span>
        <span class="c1"># to compute Fst too), but in the mean time implementing using the low-level</span>
        <span class="c1"># calls has two advantages: (a) we automatically change dimensions like the other</span>
        <span class="c1"># two-way stats and (b) it&#39;s a bit more efficient because we&#39;re not messing</span>
        <span class="c1"># around with indexes and samples sets twice.</span>

        <span class="k">def</span> <span class="nf">fst_func</span><span class="p">(</span><span class="n">sample_set_sizes</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">diversities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">divergences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence</span><span class="p">(</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># &quot;node&quot; statistics produce a 3D array</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">diversities</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">diversities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diversities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">fst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">fst</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span>
                    <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">divergences</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">])</span> <span class="o">/</span> <span class="n">denom</span>
                    <span class="p">)</span>
            <span class="n">fst</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span>
            <span class="k">return</span> <span class="n">fst</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="n">fst_func</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.Y3"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y3">[docs]</a>    <span class="k">def</span> <span class="nf">Y3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y&#39; statistic between triples of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 3`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is an average across</span>
<span class="sd">        randomly chosen trios of samples ``(a, b, c)``, one from each sample set:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The average density of sites at which ``a`` differs from ``b`` and</span>
<span class="sd">            ``c``, per unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The average length of all branches that separate ``a`` from ``b``</span>
<span class="sd">            and ``c`` (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the average proportion of the window on which ``a``</span>
<span class="sd">            inherits from that node but ``b`` and ``c`` do not, or vice-versa.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 3-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y3</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.Y2"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y2">[docs]</a>    <span class="k">def</span> <span class="nf">Y2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y2&#39; statistic between pairs of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is computed exactly as</span>
<span class="sd">        ``Y3``, except that the average across randomly chosen trios of samples</span>
<span class="sd">        ``(a, b1, b2)``, where ``a`` is chosen from the first sample set, and</span>
<span class="sd">        ``b1, b2`` are chosen (without replacement) from the second sample set.</span>
<span class="sd">        See :meth:`Y3 &lt;.TreeSequence.Y3&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y2</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.Y1"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y1">[docs]</a>    <span class="k">def</span> <span class="nf">Y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y1&#39; statistic within each of the sets of nodes given by</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on ``k = 1`` sample set at a time.</span>

<span class="sd">        What is computed depends on ``mode``. Each is computed exactly as</span>
<span class="sd">        ``Y3``, except that the average is across a randomly chosen trio of</span>
<span class="sd">        samples ``(a1, a2, a3)`` all chosen without replacement from the same</span>
<span class="sd">        sample set. See :meth:`Y3 &lt;.TreeSequence.Y3&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y1</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.f4"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f4">[docs]</a>    <span class="k">def</span> <span class="nf">f4</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f4 statistic between four groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 4`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is an average across</span>
<span class="sd">        randomly chosen set of four samples ``(a, b; c, d)``, one from each sample set:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The average density of sites at which ``a`` and ``c`` agree but</span>
<span class="sd">            differs from ``b`` and ``d``, minus the average density of sites at</span>
<span class="sd">            which ``a`` and ``d`` agree but differs from ``b`` and ``c``, per</span>
<span class="sd">            unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The average length of all branches that separate ``a`` and ``c``</span>
<span class="sd">            from ``b`` and ``d``, minus the average length of all branches that</span>
<span class="sd">            separate ``a`` and ``d`` from ``b`` and ``c`` (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the average proportion of the window on which ``a`` and ``c``</span>
<span class="sd">            inherit from that node but ``b`` and ``d`` do not, or vice-versa,</span>
<span class="sd">            minus the average proportion of the window on which ``a`` anc ``d``</span>
<span class="sd">            inherit from that node but ``b`` and ``c`` do not, or vice-versa.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 4-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f4</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.f3"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f3">[docs]</a>    <span class="k">def</span> <span class="nf">f3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f3 statistic between three groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 3`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each works exactly as</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;`, except the average is across randomly</span>
<span class="sd">        chosen set of four samples ``(a1, b; a2, c)``, with `a1` and `a2` both</span>
<span class="sd">        chosen (without replacement) from the first sample set. See</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 3-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f3</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.f2"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f2">[docs]</a>    <span class="k">def</span> <span class="nf">f2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f3 statistic between two groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each works exactly as</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;`, except the average is across randomly</span>
<span class="sd">        chosen set of four samples ``(a1, b1; a2, b2)``, with `a1` and `a2`</span>
<span class="sd">        both chosen (without replacement) from the first sample set and ``b1``</span>
<span class="sd">        and ``b2`` chosen randomly without replacement from the second sample</span>
<span class="sd">        set. See :meth:`f4 &lt;.TreeSequence.f4&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f2</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.mean_descendants"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mean_descendants">[docs]</a>    <span class="k">def</span> <span class="nf">mean_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes for every node the mean number of samples in each of the</span>
<span class="sd">        `sample_sets` that descend from that node, averaged over the</span>
<span class="sd">        portions of the genome for which the node is ancestral to *any* sample.</span>
<span class="sd">        The output is an array, `C[node, j]`, which reports the total span of</span>
<span class="sd">        all genomes in `sample_sets[j]` that inherit from `node`, divided by</span>
<span class="sd">        the total span of the genome on which `node` is an ancestor to any</span>
<span class="sd">        sample in the tree sequence.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future. The long-term stable</span>
<span class="sd">            API for this method will be consistent with other :ref:`sec_stats`.</span>
<span class="sd">            In particular, the normalization by proportion of the genome that `node`</span>
<span class="sd">            is an ancestor to anyone may not be the default behaviour in the future.</span>

<span class="sd">        :param list sample_sets: A list of lists of node IDs.</span>
<span class="sd">        :return: An array with dimensions (number of nodes in the tree sequence,</span>
<span class="sd">            number of reference sets)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">mean_descendants</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.genealogical_nearest_neighbours"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genealogical_nearest_neighbours">[docs]</a>    <span class="k">def</span> <span class="nf">genealogical_nearest_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">focal</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the genealogical nearest neighbours (GNN) proportions for the given</span>
<span class="sd">        focal nodes, with reference to two or more sets of interest, averaged over all</span>
<span class="sd">        trees in the tree sequence.</span>

<span class="sd">        The GNN proportions for a focal node in a single tree are given by first finding</span>
<span class="sd">        the most recent common ancestral node :math:`a` between the focal node and any</span>
<span class="sd">        other node present in the reference sets. The GNN proportion for a specific</span>
<span class="sd">        reference set, :math:`S` is the number of nodes in :math:`S` that descend from</span>
<span class="sd">        :math:`a`, as a proportion of the total number of descendant nodes in any of the</span>
<span class="sd">        reference sets.</span>

<span class="sd">        For example, consider a case with 2 sample sets, :math:`S_1` and :math:`S_2`.</span>
<span class="sd">        For a given tree, :math:`a` is the node that includes at least one descendant in</span>
<span class="sd">        :math:`S_1` or :math:`S_2` (not including the focal node). If the descendants of</span>
<span class="sd">        :math:`a` include some nodes in :math:`S_1` but no nodes in :math:`S_2`, then the</span>
<span class="sd">        GNN proportions for that tree will be 100% :math:`S_1` and 0% :math:`S_2`, or</span>
<span class="sd">        :math:`[1.0, 0.0]`.</span>

<span class="sd">        For a given focal node, the GNN proportions returned by this function are an</span>
<span class="sd">        average of the GNNs for each tree, weighted by the genomic distance spanned by</span>
<span class="sd">        that tree.</span>

<span class="sd">        For an precise mathematical definition of GNN, see https://doi.org/10.1101/458067</span>

<span class="sd">        .. note:: The reference sets need not include all the samples, hence the most</span>
<span class="sd">            recent common ancestral node of the reference sets, :math:`a`, need not be</span>
<span class="sd">            the immediate ancestor of the focal node. If the reference sets only comprise</span>
<span class="sd">            sequences from relatively distant individuals, the GNN statistic may end up</span>
<span class="sd">            as a measure of comparatively distant ancestry, even for tree sequences that</span>
<span class="sd">            contain many closely related individuals.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future. The long-term stable</span>
<span class="sd">            API for this method will be consistent with other :ref:`sec_stats`.</span>

<span class="sd">        :param list focal: A list of :math:`n` nodes whose GNNs should be calculated.</span>
<span class="sd">        :param list sample_sets: A list of :math:`m` lists of node IDs.</span>
<span class="sd">        :return: An :math:`n`  by :math:`m` array of focal nodes by GNN proportions.</span>
<span class="sd">            Every focal node corresponds to a row. The numbers in each</span>
<span class="sd">            row corresponding to the GNN proportion for each of the passed-in reference</span>
<span class="sd">            sets. Rows therefore sum to one.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO add windows=None option: https://github.com/tskit-dev/tskit/issues/193</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genealogical_nearest_neighbours</span><span class="p">(</span>
                <span class="n">focal</span><span class="p">,</span> <span class="n">sample_sets</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genealogical_nearest_neighbours</span><span class="p">,</span>
                <span class="n">reference_sets</span><span class="o">=</span><span class="n">sample_sets</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">focal</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">splits</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span></div>

<div class="viewcode-block" id="TreeSequence.kc_distance"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.kc_distance">[docs]</a>    <span class="k">def</span> <span class="nf">kc_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average :meth:`Tree.kc_distance` between pairs of trees along</span>
<span class="sd">        the sequence whose intervals overlap. The average is weighted by the</span>
<span class="sd">        fraction of the sequence on which each pair of trees overlap.</span>

<span class="sd">        :param TreeSequence other: The other tree sequence to compare to.</span>
<span class="sd">        :param float lambda_: The KC metric lambda parameter determining the</span>
<span class="sd">            relative weight of topology and branch length.</span>
<span class="sd">        :return: The computed KC distance between this tree sequence and other.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_kc_distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeSequence.count_topologies"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.count_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator that produces the same distribution of topologies as</span>
<span class="sd">        :meth:`Tree.count_topologies` but sequentially for every tree in a tree</span>
<span class="sd">        sequence. For use on a tree sequence this method is much faster than</span>
<span class="sd">        computing the result independently per tree.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :rtype: iter(:class:`tskit.TopologyCounter`)</span>
<span class="sd">        :raises ValueError: If nodes in ``sample_sets`` are invalid or are</span>
<span class="sd">            internal samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">()</span>
            <span class="p">]</span>

        <span class="k">yield from</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">treeseq_count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">)</span></div>

    <span class="c1">############################################</span>
    <span class="c1">#</span>
    <span class="c1"># Deprecated APIs. These are either already unsupported, or will be unsupported in a</span>
    <span class="c1"># later release.</span>
    <span class="c1">#</span>
    <span class="c1">############################################</span>

    <span class="k">def</span> <span class="nf">get_pairwise_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.pairwise_diversity</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairwise_diversity</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.pairwise_diversity"><a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pairwise_diversity">[docs]</a>    <span class="k">def</span> <span class="nf">pairwise_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the pairwise nucleotide site diversity, the average number of sites</span>
<span class="sd">        that differ between a randomly chosen pair of samples.  If `samples` is</span>
<span class="sd">        specified, calculate the diversity within this set.</span>

<span class="sd">         .. deprecated:: 0.2.0</span>
<span class="sd">             please use :meth:`.diversity` instead. Since version 0.2.0 the error</span>
<span class="sd">             semantics have also changed slightly. It is no longer an error</span>
<span class="sd">             when there is one sample and a tskit.LibraryError is raised</span>
<span class="sd">             when non-sample IDs are provided rather than a ValueError. It is</span>
<span class="sd">             also no longer an error to compute pairwise diversity at sites</span>
<span class="sd">             with multiple mutations.</span>

<span class="sd">        :param list samples: The set of samples within which we calculate</span>
<span class="sd">            the diversity. If None, calculate diversity within the entire sample.</span>
<span class="sd">        :return: The pairwise nucleotide site diversity.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span>
                <span class="p">[</span><span class="n">samples</span><span class="p">],</span> <span class="n">windows</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">],</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use ts.node(u).time</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">time</span>

    <span class="k">def</span> <span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use ts.node(u).population</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">population</span>

    <span class="k">def</span> <span class="nf">records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use either ts.edges() or ts.edgesets().</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">population</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgesets</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">CoalescenceRecord</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">],</span> <span class="n">pop</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Unsupported old methods.</span>

    <span class="k">def</span> <span class="nf">get_num_records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the &quot;</span>
            <span class="s2">&quot;TreeSequence.num_edges if possible to work with edges rather &quot;</span>
            <span class="s2">&quot;than coalescence records. If not, please use len(list(ts.edgesets())) &quot;</span>
            <span class="s2">&quot;which should return the number of coalescence records, as previously &quot;</span>
            <span class="s2">&quot;defined. Please open an issue on GitHub if this is &quot;</span>
            <span class="s2">&quot;important for your workflow.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">diffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the &quot;</span>
            <span class="s2">&quot;TreeSequence.edge_diffs() method instead&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">newick_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">breakpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the Tree.newick&quot;</span>
            <span class="s2">&quot; method instead&quot;</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">write_ms</span><span class="p">(</span>
    <span class="n">tree_sequence</span><span class="p">,</span>
    <span class="n">output</span><span class="p">,</span>
    <span class="n">print_trees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">write_header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write ``ms`` formatted output from the genotypes of a tree sequence</span>
<span class="sd">    or an iterator over tree sequences. Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import tskit as ts</span>

<span class="sd">        tree_sequence = msprime.simulate(</span>
<span class="sd">            sample_size=sample_size,</span>
<span class="sd">            Ne=Ne,</span>
<span class="sd">            length=length,</span>
<span class="sd">            mutation_rate=mutation_rate,</span>
<span class="sd">            recombination_rate=recombination_rate,</span>
<span class="sd">            random_seed=random_seed,</span>
<span class="sd">            num_replicates=num_replicates,</span>
<span class="sd">        )</span>
<span class="sd">        with open(&quot;output.ms&quot;, &quot;w&quot;) as ms_file:</span>
<span class="sd">            ts.write_ms(tree_sequence, ms_file)</span>

<span class="sd">    :param ts tree_sequence: The tree sequence (or iterator over tree sequences) to</span>
<span class="sd">        write to ms file</span>
<span class="sd">    :param io.IOBase output: The file-like object to write the ms-style output</span>
<span class="sd">    :param bool print_trees: Boolean parameter to write out newick format trees</span>
<span class="sd">        to output [optional]</span>
<span class="sd">    :param int precision: Numerical precision with which to write the ms</span>
<span class="sd">        output [optional]</span>
<span class="sd">    :param bool write_header: Boolean parameter to write out the header. [optional]</span>
<span class="sd">    :param int num_replicates: Number of replicates simulated [required if</span>
<span class="sd">        num_replicates used in simulation]</span>

<span class="sd">    The first line of this ms-style output file written has two arguments which</span>
<span class="sd">    are sample size and number of replicates. The second line has a 0 as a substitute</span>
<span class="sd">    for the random seed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree_sequence</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="n">tree_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_sequence</span><span class="p">]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">tree_seq</span> <span class="ow">in</span> <span class="n">tree_sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_header</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">write_header</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;ms </span><span class="si">{</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">sample_size</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">num_replicates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_trees</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print out the trees in ms-format from the specified tree sequence.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">())</span>
                <span class="n">newick</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">newick</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">newick</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
                    <span class="n">newick</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">newick</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">span</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">newick</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;segsites:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positions: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">position</span> <span class="o">/</span> <span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">variants</span><span class="p">()</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">position</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
                        <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

                <span class="n">genotypes</span> <span class="o">=</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">genotype_matrix</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
                    <span class="n">tmp_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">({</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">}):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;This tree sequence contains non-biallelic&quot;</span>
                            <span class="s2">&quot;SNPs and is incompatible with the ms format!&quot;</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018-2020, Tskit developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>