

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Data model &mdash; tskit 0.3.4.dev1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Metadata" href="metadata.html" />
    <link rel="prev" title="Command line interface" href="cli.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> tskit
          

          
            
            <img src="_static/tskit_logo_pale.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="stats.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Data model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#definitions">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nodes-genomes-or-individuals">Nodes, Genomes, or Individuals?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#table-definitions">Table definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#table-types">Table types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#node-table">Node Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#individual-table">Individual Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#edge-table">Edge Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#site-table">Site Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutation-table">Mutation Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#migration-table">Migration Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#population-table">Population Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#provenance-table">Provenance Table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#metadata">Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="#valid-tree-sequence-requirements">Valid tree sequence requirements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#individual-requirements">Individual requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node-requirements">Node requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#edge-requirements">Edge requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#site-requirements">Site requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutation-requirements">Mutation requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#migration-requirements">Migration requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#population-requirements">Population requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#provenance-requirements">Provenance requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#table-transformation-methods">Table transformation methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simplification">Simplification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sorting">Sorting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-indexes">Table indexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#removing-duplicate-sites">Removing duplicate sites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computing-mutation-parents">Computing mutation parents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computing-mutation-times">Computing mutation times</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recording-tables-in-forwards-time">Recording tables in forwards time</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tree-structure">Tree structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quintuply-linked-trees">Quintuply linked trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-roots">Accessing roots</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#missing-data">Missing data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#text-file-formats">Text file formats</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#individual-text-format">Individual text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node-text-format">Node text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edge-text-format">Edge text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#site-text-format">Site text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mutation-text-format">Mutation text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#migration-text-format">Migration text format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#population-text-format">Population text format</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#binary-interchange">Binary interchange</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoding-ragged-columns">Encoding ragged columns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tree-sequence-file-format">Tree sequence file format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#legacy-versions">Legacy Versions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelogs.html">Changelogs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">tskit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Data model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/tskit-dev/tskit/blob/main/docs/data-model.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="data-model">
<span id="sec-data-model"></span><h1>Data model<a class="headerlink" href="#data-model" title="Permalink to this headline">¶</a></h1>
<p>The correlated genealogical trees that describe the shared ancestry of a set of
samples are stored concisely in <code class="docutils literal notranslate"><span class="pre">tskit</span></code> as a collection of
easy-to-understand tables. These are output by coalescent simulation in
<code class="docutils literal notranslate"><span class="pre">msprime</span></code> or can be read in from another source. This page documents
the structure of the tables, and the different methods of interchanging
genealogical data to and from the tskit API. We begin by defining
the basic concepts that we need and the structure of the tables in the
<a class="reference internal" href="#data-model">Data model</a> section. We then describe the tabular text formats that can
be used as simple interchange mechanism for small amounts of data in the
<a class="reference internal" href="#text-file-formats">Text file formats</a> section. The <a class="reference internal" href="#binary-interchange">Binary interchange</a> section then describes
the efficient Python API for table interchange using numpy arrays. Finally,
we describe the binary format used by tskit to efficiently
store tree sequences on disk in the <a class="reference internal" href="#tree-sequence-file-format">Tree sequence file format</a> section.</p>
<div class="section" id="definitions">
<span id="sec-data-model-definitions"></span><h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>To begin, here are definitions of some key ideas encountered later.</p>
<dl class="simple">
<dt>tree</dt><dd><p>A “gene tree”, i.e., the genealogical tree describing how a collection of
genomes (usually at the tips of the tree) are related to each other at some
chromosomal location. See <a class="reference internal" href="#sec-nodes-or-individuals"><span class="std std-ref">Nodes, Genomes, or Individuals?</span></a> for discussion
of what a “genome” is.</p>
</dd>
<dt>tree sequence</dt><dd><p>A “succinct tree sequence” (or tree sequence, for brevity) is an efficient
encoding of a sequence of correlated trees, such as one encounters looking
at the gene trees along a genome. A tree sequence efficiently captures the
structure shared by adjacent trees, (essentially) storing only what differs
between them.</p>
</dd>
<dt>node</dt><dd><p>Each branching point in each tree is associated with a particular genome
in a particular ancestor, called “nodes”.  Since each node represents a
specific genome it has a unique <code class="docutils literal notranslate"><span class="pre">time</span></code>, thought of as its birth time,
which determines the height of any branching points it is associated with.
See <a class="reference internal" href="#sec-nodes-or-individuals"><span class="std std-ref">Nodes, Genomes, or Individuals?</span></a> for discussion of what a “node” is.</p>
</dd>
<dt>individual</dt><dd><p>In certain situations we are interested in how nodes (representing
individual homologous genomes) are grouped together into individuals
(e.g. two nodes per diploid individual). For example, when we are working
with polyploid samples it is useful to associate metadata with a specific
individual rather than duplicate this information on the constituent nodes.
See <a class="reference internal" href="#sec-nodes-or-individuals"><span class="std std-ref">Nodes, Genomes, or Individuals?</span></a> for more discussion on this point.</p>
</dd>
<dt>sample</dt><dd><p>The focal nodes of a tree sequence, usually thought of as those that we
have obtained data from. The specification of these affects various
methods: (1) <a class="reference internal" href="python-api.html#tskit.TreeSequence.variants" title="tskit.TreeSequence.variants"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.variants()</span></code></a> and
<a class="reference internal" href="python-api.html#tskit.TreeSequence.haplotypes" title="tskit.TreeSequence.haplotypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.haplotypes()</span></code></a> will output the genotypes of the samples,
and <a class="reference internal" href="python-api.html#tskit.Tree.roots" title="tskit.Tree.roots"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Tree.roots</span></code></a> only return roots ancestral to at least one
sample. (See the <a class="reference internal" href="#sec-node-table-definition"><span class="std std-ref">node table definitions</span></a>
for information on how the sample
status a node is encoded in the <code class="docutils literal notranslate"><span class="pre">flags</span></code> column.)</p>
</dd>
<dt>edge</dt><dd><p>The topology of a tree sequence is defined by a set of <strong>edges</strong>. Each
edge is a tuple <code class="docutils literal notranslate"><span class="pre">(left,</span> <span class="pre">right,</span> <span class="pre">parent,</span> <span class="pre">child)</span></code>, which records a
parent-child relationship among a pair of nodes on the
on the half-open interval of chromosome <code class="docutils literal notranslate"><span class="pre">[left,</span> <span class="pre">right)</span></code>.</p>
</dd>
<dt>site</dt><dd><p>Tree sequences can define the mutational state of nodes as well as their
topological relationships. A <strong>site</strong> is thought of as some position along
the genome at which variation occurs. Each site is associated with
a unique position and ancestral state.</p>
</dd>
<dt>mutation</dt><dd><p>A mutation records the change of state at a particular site ‘above’
a particular node (more precisely, along the branch between the node
in question and its parent). Each mutation is associated with a specific
site (which defines the position along the genome), a node (which defines
where it occurs within the tree at this position), and a derived state
(which defines the mutational state inherited by all nodes in the subtree
rooted at the focal node). In more complex situations in which we have
back or recurrent mutations, a mutation must also specify its ‘parent’
mutation.</p>
</dd>
<dt>migration</dt><dd><p>An event at which a parent and child node were born in different populations.</p>
</dd>
<dt>population</dt><dd><p>A grouping of nodes, e.g., by sampling location.</p>
</dd>
<dt>provenance</dt><dd><p>An entry recording the origin and history of the data encoded in a tree sequence.</p>
</dd>
<dt>ID</dt><dd><p>In the set of interconnected tables that we define here, we refer
throughout to the IDs of particular entities. The ID of an
entity (e.g., a node) is defined by the position of the corresponding
row in the table. These positions are zero indexed. For example, if we
refer to node with ID zero, this corresponds to the node defined by the
first row in the node table.</p>
</dd>
<dt>Sequence length</dt><dd><p>This value defines the coordinate space in which the edges and site positions
are defined. This is most often assumed to be equal to the largest
<code class="docutils literal notranslate"><span class="pre">right</span></code> coordinate in the edge table, but there are situations in which
we might wish to specify the sequence length explicitly.</p>
</dd>
</dl>
<p>A tree sequence can be stored in a collection of eight tables:
<a class="reference internal" href="#sec-node-table-definition"><span class="std std-ref">Node</span></a>,
<a class="reference internal" href="#sec-edge-table-definition"><span class="std std-ref">Edge</span></a>,
<a class="reference internal" href="#sec-individual-table-definition"><span class="std std-ref">Individual</span></a>,
<a class="reference internal" href="#sec-site-table-definition"><span class="std std-ref">Site</span></a>,
<a class="reference internal" href="#sec-mutation-table-definition"><span class="std std-ref">Mutation</span></a>,
<a class="reference internal" href="#sec-migration-table-definition"><span class="std std-ref">Migration</span></a>,
<a class="reference internal" href="#sec-population-table-definition"><span class="std std-ref">Population</span></a>, and
<a class="reference internal" href="#sec-provenance-table-definition"><span class="std std-ref">Provenance</span></a>.
The Node and Edge tables store the genealogical
relationships that define the trees, and the Individual table
describes how multiple genomes are grouped within individuals;
the Site and Mutation tables describe where mutations fall
on the trees; the Migration table describes how lineages move across space;
and the Provenance table contains information on where the data came from.
Only Node and Edge tables are necessary to encode the genealogical trees;
Sites and Mutations are optional but necessary to encode polymorphism
(sequence) data; the remainder are optional.
In the following sections we define these components of a tree sequence in
more detail.</p>
<div class="section" id="nodes-genomes-or-individuals">
<span id="sec-nodes-or-individuals"></span><h3>Nodes, Genomes, or Individuals?<a class="headerlink" href="#nodes-genomes-or-individuals" title="Permalink to this headline">¶</a></h3>
<p>The natural unit of biological analysis is (usually) the <em>individual</em>. However,
many organisms we study are diploid, and so each individual contains <em>two</em>
homologous copies of the entire genome, separately inherited from the two
parental individuals. Since each monoploid copy of the genome is inherited separately,
each diploid individual lies at the end of two distinct lineages, and so will
be represented by <em>two</em> places in any given genealogical tree. This makes it
difficult to precisely discuss tree sequences for diploids, as we have no
simple way to refer to the bundle of chromosomes that make up the “copy of the
genome inherited from one particular parent”. For this reason, in this
documentation we use the non-descriptive term “node” to refer to this concept
– and so, a diploid individual is composed of two nodes – although we use the
term “genome” at times, for concreteness.</p>
<p>Several properties naturally associated with individuals are in fact assigned
to nodes in what follows: birth time and population. This is for two reasons:
First, since coalescent simulations naturally lack a notion of polyploidy, earlier
versions of <code class="docutils literal notranslate"><span class="pre">tskit</span></code> lacked the notion of an individual. Second, ancestral
nodes are not naturally grouped together into individuals – we know they must have
existed, but have no way of inferring this grouping, so in fact many nodes in
an empirically-derived tree sequence will not be associated with individuals,
even though their birth times might be inferred.</p>
</div>
</div>
<div class="section" id="table-definitions">
<span id="sec-table-definitions"></span><h2>Table definitions<a class="headerlink" href="#table-definitions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="table-types">
<span id="sec-table-types-definitions"></span><h3>Table types<a class="headerlink" href="#table-types" title="Permalink to this headline">¶</a></h3>
<div class="section" id="node-table">
<span id="sec-node-table-definition"></span><h4>Node Table<a class="headerlink" href="#node-table" title="Permalink to this headline">¶</a></h4>
<p>A <strong>node</strong> defines a monoploid set of chromosomes (a “genome”) of a specific
individual that was born at some time in the past: the set of
chromosomes inherited from a particular one of the individual’s parents.
(See <a class="reference internal" href="#sec-nodes-or-individuals"><span class="std std-ref">Nodes, Genomes, or Individuals?</span></a> for more discussion.)
Every vertex in the marginal trees of a tree sequence corresponds
to exactly one node, and a node may be present in many trees. The
node table contains five columns, of which <code class="docutils literal notranslate"><span class="pre">flags</span></code> and <code class="docutils literal notranslate"><span class="pre">time</span></code> are
mandatory:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 22%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>flags</p></td>
<td><p>uint32</p></td>
<td><p>Bitwise flags.</p></td>
</tr>
<tr class="row-odd"><td><p>time</p></td>
<td><p>double</p></td>
<td><p>Birth time of node</p></td>
</tr>
<tr class="row-even"><td><p>population</p></td>
<td><p>int32</p></td>
<td><p>Birth population of node.</p></td>
</tr>
<tr class="row-odd"><td><p>individual</p></td>
<td><p>int32</p></td>
<td><p>The individual the node belongs to.</p></td>
</tr>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Node <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a></p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">time</span></code> column records the birth time of the individual in question,
and is a floating point value. Similarly,
the <code class="docutils literal notranslate"><span class="pre">population</span></code> column records the ID of the population where this
individual was born. If not provided, <code class="docutils literal notranslate"><span class="pre">population</span></code> defaults to the
null ID (-1). Otherwise, the population ID must refer to a row in the
<a class="reference internal" href="#sec-population-table-definition"><span class="std std-ref">Population Table</span></a>.
The <code class="docutils literal notranslate"><span class="pre">individual</span></code> column records the ID of the
<a class="reference internal" href="#sec-individual-table-definition"><span class="std std-ref">Individual</span></a>
individual that this node belongs to. If specified, the ID must refer
to a valid individual. If not provided, <code class="docutils literal notranslate"><span class="pre">individual</span></code>
defaults to the null ID (-1).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> column stores information about a particular node, and
is composed of 32 bitwise boolean values. Currently, the only flag defined
is <code class="docutils literal notranslate"><span class="pre">NODE_IS_SAMPLE</span> <span class="pre">=</span> <span class="pre">1</span></code>, which defines the <em>sample</em> status of nodes. Marking
a particular node as a “sample” means, for example, that the mutational state
of the node will be included in the genotypes produced by
<a class="reference internal" href="python-api.html#tskit.TreeSequence.variants" title="tskit.TreeSequence.variants"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.variants()</span></code></a>.</p>
<p>Bits 0-15 (inclusive) of the <code class="docutils literal notranslate"><span class="pre">flags</span></code> column are reserved for internal use by
<code class="docutils literal notranslate"><span class="pre">tskit</span></code> and should not be used by applications for anything other
than the purposes documented here. Bits 16-31 (inclusive) are free for applications
to use for any purpose and will not be altered or interpreteted by
<code class="docutils literal notranslate"><span class="pre">tskit</span></code>.</p>
<p>See the <a class="reference internal" href="#sec-node-requirements"><span class="std std-ref">Node requirements</span></a> section for details on the properties
required for a valid set of nodes.</p>
<p>For convenience, the <a class="reference internal" href="#sec-text-file-format"><span class="std std-ref">text format</span></a> for nodes
decomposes the <code class="docutils literal notranslate"><span class="pre">flags</span></code> value into its separate values. Thus, in the
text format we have a column for <code class="docutils literal notranslate"><span class="pre">is_sample</span></code>, which corresponds to the
<code class="docutils literal notranslate"><span class="pre">flags</span></code> column in the underlying table. As more flags values are
defined, these will be added to the text file format.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each node. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The distinction between <code class="docutils literal notranslate"><span class="pre">flags</span></code> and <code class="docutils literal notranslate"><span class="pre">metadata</span></code> is that flags
holds information about a node that the library understands, whereas
metadata holds information about a node that the library <em>does not</em>
understand. Metadata is for storing auxiliarly information that is
not necessary for the core tree sequence algorithms.</p>
</div>
</div>
<div class="section" id="individual-table">
<span id="sec-individual-table-definition"></span><h4>Individual Table<a class="headerlink" href="#individual-table" title="Permalink to this headline">¶</a></h4>
<p>An <strong>individual</strong> defines how nodes (which can be seen
as representing single chromosomes) group together in a polyploid individual.
The individual table contains three columns, of which only <code class="docutils literal notranslate"><span class="pre">flags</span></code> is mandatory.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>flags</p></td>
<td><p>uint32</p></td>
<td><p>Bitwise flags.</p></td>
</tr>
<tr class="row-odd"><td><p>location</p></td>
<td><p>double</p></td>
<td><p>Location in arbitrary dimensions</p></td>
</tr>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Individual <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a></p></td>
</tr>
</tbody>
</table>
<p>See the <a class="reference internal" href="#sec-individual-requirements"><span class="std std-ref">Individual requirements</span></a> section for details on the properties
required for a valid set of individuals.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> column stores information about a particular individual, and
is composed of 32 bitwise boolean values. Currently, no flags are
defined.</p>
<p>Bits 0-15 (inclusive) of the <code class="docutils literal notranslate"><span class="pre">flags</span></code> column are reserved for internal use by
<code class="docutils literal notranslate"><span class="pre">tskit</span></code> and should not be used by applications for anything other
than the purposes documented here. Bits 16-31 (inclusive) are free for applications
to use for any purpose and will not be altered or interpreteted by
<code class="docutils literal notranslate"><span class="pre">tskit</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">location</span></code> column stores the location of an individual in arbitrary
dimensions. This column is <a class="reference internal" href="#sec-encoding-ragged-columns"><span class="std std-ref">ragged</span></a>, and
so different individuals can have locations with different dimensions (i.e.,
one individual may have location <code class="docutils literal notranslate"><span class="pre">[]</span></code> and another <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>. This could
therefore be used to store other quantities (e.g., phenotype).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each individual. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The distinction between <code class="docutils literal notranslate"><span class="pre">flags</span></code> and <code class="docutils literal notranslate"><span class="pre">metadata</span></code> is that flags
holds information about a individual that the library understands, whereas
metadata holds information about a individual that the library <em>does not</em>
understand. Metadata is for storing auxiliarly information that is
not necessary for the core tree sequence algorithms.</p>
</div>
</div>
<div class="section" id="edge-table">
<span id="sec-edge-table-definition"></span><h4>Edge Table<a class="headerlink" href="#edge-table" title="Permalink to this headline">¶</a></h4>
<p>An <strong>edge</strong> defines a parent-child relationship between a pair of nodes
over a specific sequence interval. The edge table contains five columns,
all of which are mandatory except <code class="docutils literal notranslate"><span class="pre">metadata</span></code>:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>left</p></td>
<td><p>double</p></td>
<td><p>Left coordinate of the edge (inclusive).</p></td>
</tr>
<tr class="row-odd"><td><p>right</p></td>
<td><p>double</p></td>
<td><p>Right coordinate of the edge (exclusive).</p></td>
</tr>
<tr class="row-even"><td><p>parent</p></td>
<td><p>int32</p></td>
<td><p>Parent node ID.</p></td>
</tr>
<tr class="row-odd"><td><p>child</p></td>
<td><p>int32</p></td>
<td><p>Child node ID.</p></td>
</tr>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Node <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a></p></td>
</tr>
</tbody>
</table>
<p>Each row in an edge table describes a half-open genomic interval <code class="docutils literal notranslate"><span class="pre">[left,</span> <span class="pre">right)</span></code>
over which the <code class="docutils literal notranslate"><span class="pre">child</span></code> inherited from the given <code class="docutils literal notranslate"><span class="pre">parent</span></code>.
The <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> columns are defined using double precision
floating point values. The <code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">child</span></code>
columns specify integer IDs in the associated <a class="reference internal" href="#sec-node-table-definition"><span class="std std-ref">Node Table</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each edge. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<p>See the <a class="reference internal" href="#sec-edge-requirements"><span class="std std-ref">Edge requirements</span></a> section for details on the properties
required for a valid set of edges.</p>
</div>
<div class="section" id="site-table">
<span id="sec-site-table-definition"></span><h4>Site Table<a class="headerlink" href="#site-table" title="Permalink to this headline">¶</a></h4>
<p>A <strong>site</strong> defines a particular location along the genome in which
we are interested in observing the allelic state. The site table
contains three columns, of which <code class="docutils literal notranslate"><span class="pre">position</span></code> and <code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code>
are mandatory.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>position</p></td>
<td><p>double</p></td>
<td><p>Position of site in genome coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p>ancestral_state</p></td>
<td><p>text</p></td>
<td><p>The state at the root of the tree.</p></td>
</tr>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Site <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a>.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">position</span></code> column is a floating point value defining the location
of the site in question along the genome.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code> column specifies the allelic state at the root
of the tree, thus defining the state that nodes inherit if no mutations
intervene. The column stores text character data of arbitrary length.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each site. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<p>See the <a class="reference internal" href="#sec-site-requirements"><span class="std std-ref">Site requirements</span></a> section for details on the properties
required for a valid set of sites.</p>
</div>
<div class="section" id="mutation-table">
<span id="sec-mutation-table-definition"></span><h4>Mutation Table<a class="headerlink" href="#mutation-table" title="Permalink to this headline">¶</a></h4>
<p>A <strong>mutation</strong> defines a change of allelic state on a tree at a particular site.
The mutation table contains five columns, of which <code class="docutils literal notranslate"><span class="pre">site</span></code>, <code class="docutils literal notranslate"><span class="pre">node</span></code> and
<code class="docutils literal notranslate"><span class="pre">derived_state</span></code> are mandatory.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 18%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>site</p></td>
<td><p>int32</p></td>
<td><p>The ID of the site the mutation occurs at.</p></td>
</tr>
<tr class="row-odd"><td><p>node</p></td>
<td><p>int32</p></td>
<td><p>The node this mutation occurs at.</p></td>
</tr>
<tr class="row-even"><td><p>parent</p></td>
<td><p>int32</p></td>
<td><p>The ID of the parent mutation.</p></td>
</tr>
<tr class="row-odd"><td><p>time</p></td>
<td><p>double</p></td>
<td><p>Time at which the mutation occurred.</p></td>
</tr>
<tr class="row-even"><td><p>derived_state</p></td>
<td><p>char</p></td>
<td><p>The allelic state resulting from the mutation.</p></td>
</tr>
<tr class="row-odd"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Mutation <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a>.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">site</span></code> column is an integer value defining the ID of the
<a class="reference internal" href="#sec-site-table-definition"><span class="std std-ref">site</span></a> at which this mutation occurred.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">node</span></code> column is an integer value defining the ID of the
first <a class="reference internal" href="#sec-node-table-definition"><span class="std std-ref">node</span></a> in the tree below this mutation.</p>
<p>The  <code class="docutils literal notranslate"><span class="pre">time</span></code> column is a double precision floating point value recording how long ago
the mutation happened.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">derived_state</span></code> column specifies the allelic state resulting from the mutation,
thus defining the state that the <code class="docutils literal notranslate"><span class="pre">node</span></code> and any descendant nodes in the
subtree inherit unless further mutations occur. The column stores text
character data of arbitrary length.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">parent</span></code> column is an integer value defining the ID of the mutation whose
allelic state this mutation replaced. If there is no mutation at the
site in question on the path back to root, then this field is set to the
null ID (-1). (The <code class="docutils literal notranslate"><span class="pre">parent</span></code> column is only required in situations
where there are multiple mutations at a given site. For
“infinite sites” mutations, it can be ignored.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each site. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<p>See the <a class="reference internal" href="#sec-mutation-requirements"><span class="std std-ref">Mutation requirements</span></a> section for details on the properties
required for a valid set of mutations.</p>
</div>
<div class="section" id="migration-table">
<span id="sec-migration-table-definition"></span><h4>Migration Table<a class="headerlink" href="#migration-table" title="Permalink to this headline">¶</a></h4>
<p>In simulations, trees can be thought of as spread across space, and it is
helpful for inferring demographic history to record this history.
Migrations are performed by individual ancestors, but most likely not by an
individual whose genome is tracked as a <code class="docutils literal notranslate"><span class="pre">node</span></code> (as in a discrete-deme model they are
unlikely to be both a migrant and a most recent common ancestor).  So,
<code class="docutils literal notranslate"><span class="pre">tskit</span></code> records when a segment of ancestry has moved between
populations. This table is not required, even if different nodes come from
different populations.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>left</p></td>
<td><p>double</p></td>
<td><p>Left coordinate of the migrating segment (inclusive).</p></td>
</tr>
<tr class="row-odd"><td><p>right</p></td>
<td><p>double</p></td>
<td><p>Right coordinate of the migrating segment (exclusive).</p></td>
</tr>
<tr class="row-even"><td><p>node</p></td>
<td><p>int32</p></td>
<td><p>Node ID.</p></td>
</tr>
<tr class="row-odd"><td><p>source</p></td>
<td><p>int32</p></td>
<td><p>Source population ID.</p></td>
</tr>
<tr class="row-even"><td><p>dest</p></td>
<td><p>int32</p></td>
<td><p>Destination population ID.</p></td>
</tr>
<tr class="row-odd"><td><p>time</p></td>
<td><p>double</p></td>
<td><p>Time of migration event.</p></td>
</tr>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Migration <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a></p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> columns are floating point values defining the
half-open segment of genome affected. The <code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">dest</span></code> columns
record the IDs of the respective populations. The <code class="docutils literal notranslate"><span class="pre">node</span></code> column records the
ID of the node that was associated with the ancestry segment in question
at the time of the migration event. The <code class="docutils literal notranslate"><span class="pre">time</span></code> column is holds floating
point values recording the time of the event.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each migration. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<p>See the <a class="reference internal" href="#sec-migration-requirements"><span class="std std-ref">Migration requirements</span></a> section for details on the properties
required for a valid set of mutations.</p>
</div>
<div class="section" id="population-table">
<span id="sec-population-table-definition"></span><h4>Population Table<a class="headerlink" href="#population-table" title="Permalink to this headline">¶</a></h4>
<p>A <strong>population</strong> defines a grouping of individuals that a node can
be said to belong to.</p>
<p>The population table contains one column, <code class="docutils literal notranslate"><span class="pre">metadata</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 19%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metadata</p></td>
<td><p>binary</p></td>
<td><p>Population <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a>.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column provides a location for client code to store
information about each population. See the <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> section for
more details on how metadata columns should be used.</p>
<p>See the <a class="reference internal" href="#sec-population-requirements"><span class="std std-ref">Population requirements</span></a> section for details on the properties
required for a valid set of populations.</p>
</div>
<div class="section" id="provenance-table">
<span id="sec-provenance-table-definition"></span><h4>Provenance Table<a class="headerlink" href="#provenance-table" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Document the provenance table.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 14%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>timestamp</p></td>
<td><p>char</p></td>
<td><p>Timestamp in <a class="reference external" href="https://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a> format.</p></td>
</tr>
<tr class="row-odd"><td><p>record</p></td>
<td><p>char</p></td>
<td><p>Provenance record.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="metadata">
<span id="sec-metadata-definition"></span><h3>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<p>Each table (excluding provenance) has a metadata column for storing and passing along
information that tskit does not use or interpret. See <a class="reference internal" href="metadata.html#sec-metadata"><span class="std std-ref">Metadata</span></a> for details.
The metadata columns are <a class="reference internal" href="python-api.html#sec-tables-api-binary-columns"><span class="std std-ref">binary columns</span></a>.</p>
<p>When using the <a class="reference internal" href="#sec-text-file-format"><span class="std std-ref">Text file formats</span></a>, to ensure that metadata can be safely
interchanged, each row is <a class="reference external" href="https://en.wikipedia.org/wiki/Base64">base 64 encoded</a>.
Thus, binary information can be safely printed and exchanged, but may not be
human readable.</p>
<p>The tree sequence itself also has metadata stored as a byte array.</p>
</div>
<div class="section" id="valid-tree-sequence-requirements">
<span id="sec-valid-tree-sequence-requirements"></span><h3>Valid tree sequence requirements<a class="headerlink" href="#valid-tree-sequence-requirements" title="Permalink to this headline">¶</a></h3>
<p>Arbitrary data can be stored in tables using the classes in the
<a class="reference internal" href="python-api.html#sec-tables-api"><span class="std std-ref">Tables and Table Collections</span></a>. However, only a <a class="reference internal" href="python-api.html#tskit.TableCollection" title="tskit.TableCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableCollection</span></code></a>
that fulfils a set of requirements represents
a valid <a class="reference internal" href="python-api.html#tskit.TreeSequence" title="tskit.TreeSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeSequence</span></code></a> object which can be obtained
using the <a class="reference internal" href="python-api.html#tskit.TableCollection.tree_sequence" title="tskit.TableCollection.tree_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.tree_sequence()</span></code></a> method. In this
section we list these requirements, and explain their rationale.
Violations of most of these requirements are detected when the
user attempts to load a tree sequence via <a class="reference internal" href="python-api.html#tskit.load" title="tskit.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">tskit.load()</span></code></a> or
<a class="reference internal" href="python-api.html#tskit.TableCollection.tree_sequence" title="tskit.TableCollection.tree_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.tree_sequence()</span></code></a>, raising an informative
error message. Some more complex requirements may not be detectable at load-time,
and errors may not occur until certain operations are attempted.
These are documented below.
We also provide tools that can transform a collection of tables into a valid
collection of tables, so long as they are logically consistent,
as described in <a class="reference internal" href="#sec-table-transformations"><span class="std std-ref">Table transformation methods</span></a>.</p>
<div class="section" id="individual-requirements">
<span id="sec-individual-requirements"></span><h4>Individual requirements<a class="headerlink" href="#individual-requirements" title="Permalink to this headline">¶</a></h4>
<p>Individuals are a basic type in a tree sequence and are not defined with
respect to any other tables. Therefore, there are no requirements on
individuals.</p>
<p>There are no requirements regarding the ordering of individuals.
Sorting a set of tables using <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> has
no effect on the individuals.</p>
</div>
<div class="section" id="node-requirements">
<span id="sec-node-requirements"></span><h4>Node requirements<a class="headerlink" href="#node-requirements" title="Permalink to this headline">¶</a></h4>
<p>Given a valid set of individuals and populations, the requirements for
each node are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">population</span></code> must either be null (-1) or refer to a valid population ID;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">individual</span></code> must either be null (-1) or refer to a valid individual ID.</p></li>
</ul>
<p>An ID refers to a zero-indexed row number in the relevant table,
and so is “valid” if is between 0 and one less than the number of rows in the relevant table.</p>
<p>There are no requirements regarding the ordering of nodes with respect to time.</p>
<p>Sorting a set of tables using <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a>
has no effect on nodes.</p>
</div>
<div class="section" id="edge-requirements">
<span id="sec-edge-requirements"></span><h4>Edge requirements<a class="headerlink" href="#edge-requirements" title="Permalink to this headline">¶</a></h4>
<p>Given a valid set of nodes and a sequence length <span class="math notranslate nohighlight">\(L\)</span>, the simple
requirements for each edge are:</p>
<ul class="simple">
<li><p>We must have <span class="math notranslate nohighlight">\(0 \leq\)</span> <code class="docutils literal notranslate"><span class="pre">left</span></code> <span class="math notranslate nohighlight">\(&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">right</span></code> <span class="math notranslate nohighlight">\(\leq L\)</span>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">child</span></code> must be valid node IDs;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time[parent]</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">time[child]</span></code>;</p></li>
<li><p>edges must be unique (i.e., no duplicate edges are allowed).</p></li>
</ul>
<p>The first requirement simply ensures that the interval makes sense. The
third requirement ensures that we cannot have loops, since time is
always increasing as we ascend the tree.</p>
<p>To ensure a valid tree sequence there is one further requirement:</p>
<ul class="simple">
<li><p>The set of intervals on which each node is a child must be disjoint.</p></li>
</ul>
<p>This guarantees that we cannot have contradictory edges (i.e.,
where a node <code class="docutils literal notranslate"><span class="pre">a</span></code> is a child of both <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>), and ensures that
at each point on the sequence we have a well-formed forest of trees.
Because this is a more complex semantic requirement, it is <strong>not</strong> detected
at load time. This error is detected during tree traversal, via, e.g.,
the <a class="reference internal" href="python-api.html#tskit.TreeSequence.trees" title="tskit.TreeSequence.trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.trees()</span></code></a> iterator.</p>
<p>In the interest of algorithmic efficiency, edges must have the following
sortedness properties:</p>
<ul class="simple">
<li><p>All edges for a given parent must be contiguous;</p></li>
<li><p>Edges must be listed in nondecreasing order of <code class="docutils literal notranslate"><span class="pre">parent</span></code> time;</p></li>
<li><p>Within the edges for a given <code class="docutils literal notranslate"><span class="pre">parent</span></code>, edges must be sorted
first by <code class="docutils literal notranslate"><span class="pre">child</span></code> ID and then by <code class="docutils literal notranslate"><span class="pre">left</span></code> coordinate.</p></li>
</ul>
<p>Violations of these requirements are detected at load time.
The <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> method will ensure that these sortedness
properties are fulfilled.</p>
</div>
<div class="section" id="site-requirements">
<span id="sec-site-requirements"></span><h4>Site requirements<a class="headerlink" href="#site-requirements" title="Permalink to this headline">¶</a></h4>
<p>Given a valid set of nodes and a sequence length <span class="math notranslate nohighlight">\(L\)</span>, the simple
requirements for a valid set of sites are:</p>
<ul class="simple">
<li><p>We must have <span class="math notranslate nohighlight">\(0 \leq\)</span> <code class="docutils literal notranslate"><span class="pre">position</span></code> <span class="math notranslate nohighlight">\(&lt; L\)</span>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">position</span></code> values must be unique.</p></li>
</ul>
<p>For simplicity and algorithmic efficiency, sites must also:</p>
<ul class="simple">
<li><p>Be sorted in increasing order of <code class="docutils literal notranslate"><span class="pre">position</span></code>.</p></li>
</ul>
<p>Violations of these requirements are detected at load time.
The <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> method ensures that sites are sorted
according to these criteria.</p>
</div>
<div class="section" id="mutation-requirements">
<span id="sec-mutation-requirements"></span><h4>Mutation requirements<a class="headerlink" href="#mutation-requirements" title="Permalink to this headline">¶</a></h4>
<p>Given a valid set of nodes, edges and sites, the
requirements for a valid set of mutations are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">site</span></code> must refer to a valid site ID;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code> must refer to a valid node ID;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code> must either be <code class="docutils literal notranslate"><span class="pre">UNKNOWN_TIME</span></code> (a NAN value which indicates
the time is unknown) or be a finite value which is greater or equal to the
mutation <code class="docutils literal notranslate"><span class="pre">node</span></code>’s <code class="docutils literal notranslate"><span class="pre">time</span></code>, less than the <code class="docutils literal notranslate"><span class="pre">node</span></code> above the mutation’s
<code class="docutils literal notranslate"><span class="pre">time</span></code> and equal to or less than the <code class="docutils literal notranslate"><span class="pre">time</span></code> of the <code class="docutils literal notranslate"><span class="pre">parent</span></code> mutation
if this mutation has one. If one mutation on a site has <code class="docutils literal notranslate"><span class="pre">UNKNOWN_TIME</span></code> then
all mutations at that site must, as a mixture of known and unknown is not valid.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code> must either be the null ID (-1) or a valid mutation ID within the
current table</p></li>
</ul>
<p>Furthermore,</p>
<ul class="simple">
<li><p>If another mutation occurs on the tree above the mutation in
question, its ID must be listed as the <code class="docutils literal notranslate"><span class="pre">parent</span></code>.</p></li>
</ul>
<p>For simplicity and algorithmic efficiency, mutations must also:</p>
<ul class="simple">
<li><p>be sorted by site ID;</p></li>
<li><p>when there are multiple mutations per site, mutations should be ordered by
decreasing time, if known, and parent mutations must occur
<strong>before</strong> their children (i.e. if a mutation with ID <span class="math notranslate nohighlight">\(x\)</span> has
<code class="docutils literal notranslate"><span class="pre">parent</span></code> with ID <span class="math notranslate nohighlight">\(y\)</span>, then we must have <span class="math notranslate nohighlight">\(y &lt; x\)</span>).</p></li>
</ul>
<p>Violations of these sorting requirements are detected at load time.
The <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> method ensures that mutations are sorted
according site ID, but does not at present enforce that mutations occur
after their parent mutations.</p>
<p>Mutations also have the requirement that they must result in a
change of state. For example, if we have a site with ancestral state
of “A” and a single mutation with derived state “A”, then this
mutation does not result in any change of state. This error is
raised at run-time when we reconstruct sample genotypes, for example
in the <a class="reference internal" href="python-api.html#tskit.TreeSequence.variants" title="tskit.TreeSequence.variants"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.variants()</span></code></a> iterator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As <code class="docutils literal notranslate"><span class="pre">tskit.UNKNOWN_TIME</span></code> is implemented as a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> value, tests for
equality will always fail. Use <code class="docutils literal notranslate"><span class="pre">tskit.is_unknown_time</span></code> to detect unknown
values.</p>
</div>
</div>
<div class="section" id="migration-requirements">
<span id="sec-migration-requirements"></span><h4>Migration requirements<a class="headerlink" href="#migration-requirements" title="Permalink to this headline">¶</a></h4>
<p>Given a valid set of nodes and edges, the requirements for a value set of
migrations are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> must lie within the tree sequence coordinate space (i.e.,
from 0 to <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code> must be strictly between the time of its <code class="docutils literal notranslate"><span class="pre">node</span></code> and the time of any
ancestral node from which that node inherits on the segment <code class="docutils literal notranslate"><span class="pre">[left,</span> <span class="pre">right)</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">population</span></code> of any such ancestor matching <code class="docutils literal notranslate"><span class="pre">source</span></code>, if another
<code class="docutils literal notranslate"><span class="pre">migration</span></code> does not intervene.</p></li>
</ul>
<p>To enable efficient processing, migrations must also be:</p>
<ul class="simple">
<li><p>Sorted by nondecreasing <code class="docutils literal notranslate"><span class="pre">time</span></code> value.</p></li>
</ul>
<p>Note in particular that there is no requirement that adjacent migration records
should be “squashed”. That is, we can have two records <code class="docutils literal notranslate"><span class="pre">m1</span></code> and <code class="docutils literal notranslate"><span class="pre">m2</span></code>
such that <code class="docutils literal notranslate"><span class="pre">m1.right</span></code> = <code class="docutils literal notranslate"><span class="pre">m2.left</span></code> and with the <code class="docutils literal notranslate"><span class="pre">node</span></code>, <code class="docutils literal notranslate"><span class="pre">source</span></code>,
<code class="docutils literal notranslate"><span class="pre">dest</span></code> and <code class="docutils literal notranslate"><span class="pre">time</span></code> fields equal. This is because such records will usually
represent two independent ancestral segments migrating at the same time, and
as such squashing them into a single record would result in a loss of information.</p>
</div>
<div class="section" id="population-requirements">
<span id="sec-population-requirements"></span><h4>Population requirements<a class="headerlink" href="#population-requirements" title="Permalink to this headline">¶</a></h4>
<p>There are no requirements on a population table.</p>
</div>
<div class="section" id="provenance-requirements">
<span id="sec-provenance-requirements"></span><h4>Provenance requirements<a class="headerlink" href="#provenance-requirements" title="Permalink to this headline">¶</a></h4>
<p>The <cite>timestamp</cite> column of a provenance table should be in
<a class="reference external" href="https://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a> format.</p>
<p>The <cite>record</cite> should be valid JSON with structure defined in the Provenance
Schema section (TODO).</p>
</div>
</div>
<div class="section" id="table-transformation-methods">
<span id="sec-table-transformations"></span><h3>Table transformation methods<a class="headerlink" href="#table-transformation-methods" title="Permalink to this headline">¶</a></h3>
<p>In several cases it may be necessary to transform the data stored in a
<a class="reference internal" href="python-api.html#tskit.TableCollection" title="tskit.TableCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableCollection</span></code></a>. For example, an application may produce tables
which, while logically consistent, do not meet all the
<a class="reference internal" href="#sec-valid-tree-sequence-requirements"><span class="std std-ref">requirements</span></a> for a valid tree
sequence, which exist for algorithmic and efficiency reasons; table
transformation methods can make such a set of tables valid, and thus ready
to be loaded into a tree sequence.</p>
<p>In general, table methods operate <em>in place</em> on a <a class="reference internal" href="python-api.html#tskit.TableCollection" title="tskit.TableCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableCollection</span></code></a>,
directly altering the data stored within its constituent tables.
Some of the methods described in this section also have an equivalant
<a class="reference internal" href="python-api.html#tskit.TreeSequence" title="tskit.TreeSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeSequence</span></code></a> version: unlike the methods described below,
<a class="reference internal" href="python-api.html#tskit.TreeSequence" title="tskit.TreeSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeSequence</span></code></a> methods do <em>not</em> operate in place, but rather act in
a functional way, returning a new tree sequence while leaving the original
unchanged.</p>
<p>This section is best skipped unless you are writing a program that records
tables directly.</p>
<div class="section" id="simplification">
<span id="sec-table-simplification"></span><h4>Simplification<a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h4>
<p>Simplifying a tree sequence is an operation commonly used to remove
redundant information and only retain the minimal tree sequence necessary
to describe the genealogical history of the <code class="docutils literal notranslate"><span class="pre">samples</span></code> provided. In fact all
that the <a class="reference internal" href="python-api.html#tskit.TreeSequence.simplify" title="tskit.TreeSequence.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.simplify()</span></code></a> method does is to call the equivalent
table transformation method, <a class="reference internal" href="python-api.html#tskit.TableCollection.simplify" title="tskit.TableCollection.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.simplify()</span></code></a>, on the
underlying tables and load them in a new tree sequence.</p>
<p>Removing information via <a class="reference internal" href="python-api.html#tskit.TableCollection.simplify" title="tskit.TableCollection.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.simplify()</span></code></a> is done by
discarding rows from the underlying tables. Nevertheless, simplification is
guaranteed to preserve relative ordering of any retained rows in the Site
and Mutation tables.</p>
<p>The <a class="reference internal" href="python-api.html#tskit.TableCollection.simplify" title="tskit.TableCollection.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.simplify()</span></code></a> method can be applied to a collection of
tables that does not have the <code class="docutils literal notranslate"><span class="pre">mutations.parent</span></code> entries filled in, as long
as all other validity requirements are satisfied.</p>
</div>
<div class="section" id="sorting">
<span id="sec-table-sorting"></span><h4>Sorting<a class="headerlink" href="#sorting" title="Permalink to this headline">¶</a></h4>
<p>The validity requirements for a set of tables to be loaded into a tree sequence
listed in <a class="reference internal" href="#sec-table-definitions"><span class="std std-ref">Table definitions</span></a> are of two sorts: logical consistency,
and sortedness. The <a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> method can be used to make
completely valid a set of tables that satisfies all requirements other than
sortedness.</p>
<p>This method can also be used on slightly more general collections of tables:
it is not required that <code class="docutils literal notranslate"><span class="pre">site</span></code> positions be unique in the table collection to
be sorted. The method has two additional properties:</p>
<ul class="simple">
<li><p>it preserves relative ordering between sites at the same position, and</p></li>
<li><p>it preserves relative ordering between mutations at the same site.</p></li>
</ul>
<p><a class="reference internal" href="python-api.html#tskit.TableCollection.sort" title="tskit.TableCollection.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.sort()</span></code></a> does not check the validity of the <cite>parent</cite>
property of the mutation table. However, because the method preserves mutation
order among mutations at the same site, if mutations are already sorted so that
each mutation comes after its parent (e.g., if they are ordered by time of
appearance), then this property is preserved, even if the <cite>parent</cite> properties
are not specified.</p>
</div>
<div class="section" id="table-indexes">
<span id="sec-table-indexes"></span><h4>Table indexes<a class="headerlink" href="#table-indexes" title="Permalink to this headline">¶</a></h4>
<p>To efficiently iterate over the trees in a tree sequence, <code class="docutils literal notranslate"><span class="pre">tskit</span></code> uses
indexes built on the edges. To create a tree sequence from a table collection
the tables must be indexed; the <a class="reference internal" href="python-api.html#tskit.TableCollection.build_index" title="tskit.TableCollection.build_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.build_index()</span></code></a> method
can be used to create an index on a table collection if necessary.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Add more details on what the indexes actually are.</p>
</div>
</div>
<div class="section" id="removing-duplicate-sites">
<h4>Removing duplicate sites<a class="headerlink" href="#removing-duplicate-sites" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="python-api.html#tskit.TableCollection.deduplicate_sites" title="tskit.TableCollection.deduplicate_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.deduplicate_sites()</span></code></a> method can be used to save a tree
sequence recording method the bother of checking to see if a given site already
exists in the site table. If there is more than one site with the same
position, all but the first is removed, and all mutations referring to the
removed sites are edited to refer to the first (and remaining) site. Order is
preserved.</p>
</div>
<div class="section" id="computing-mutation-parents">
<h4>Computing mutation parents<a class="headerlink" href="#computing-mutation-parents" title="Permalink to this headline">¶</a></h4>
<p>If each edge had at most only a single mutation, then the <code class="docutils literal notranslate"><span class="pre">parent</span></code> property
of the mutation table would be easily inferred from the tree at that mutation’s
site. If mutations are entered into the mutation table ordered by time of
appearance, then this sortedness allows us to infer the parent of each mutation
even for mutations occurring on the same branch. The
<a class="reference internal" href="python-api.html#tskit.TableCollection.compute_mutation_parents" title="tskit.TableCollection.compute_mutation_parents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.compute_mutation_parents()</span></code></a> method will take advantage
of this fact to compute the <code class="docutils literal notranslate"><span class="pre">parent</span></code> column of a mutation table, if all
other information is valid.</p>
</div>
<div class="section" id="computing-mutation-times">
<h4>Computing mutation times<a class="headerlink" href="#computing-mutation-times" title="Permalink to this headline">¶</a></h4>
<p>In the case where the method generating a tree sequence does not generate mutation
times, valid times can be provided by <a class="reference internal" href="python-api.html#tskit.TableCollection.compute_mutation_parents" title="tskit.TableCollection.compute_mutation_parents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableCollection.compute_mutation_parents()</span></code></a>.
If all other information is valid this method will assign times to the mutations by
placing them at evenly spaced intervals along their edge (for instance, a single
mutation on an edge between a node at time 1.0 and a node at time 4.0 would be given
time 2.5; while two mutations on that edge would be given times 2.0 and 3.0).</p>
</div>
<div class="section" id="recording-tables-in-forwards-time">
<h4>Recording tables in forwards time<a class="headerlink" href="#recording-tables-in-forwards-time" title="Permalink to this headline">¶</a></h4>
<p>The above methods enable the following scheme for recording site and mutation
tables during a forwards-time simulation. Whenever a new mutation is
encountered:</p>
<ol class="arabic simple">
<li><p>Add a new <code class="docutils literal notranslate"><span class="pre">site</span></code> to the site table at this position.</p></li>
<li><p>Add a new <code class="docutils literal notranslate"><span class="pre">mutation</span></code> to the mutation table at the newly created site.</p></li>
</ol>
<p>This is lazy and wrong, because:</p>
<ol class="loweralpha simple">
<li><p>There might have already been sites in the site table with the same position,</p></li>
<li><p>and/or a mutation (at the same position) that this mutation should record as
its <code class="docutils literal notranslate"><span class="pre">parent</span></code>.</p></li>
</ol>
<p>But, it’s all OK because here’s what we do:</p>
<ol class="arabic simple">
<li><p>Add rows to the mutation and site tables as described above.</p></li>
<li><p>Periodically, <code class="docutils literal notranslate"><span class="pre">sort</span></code>, <code class="docutils literal notranslate"><span class="pre">deduplicate_sites</span></code>,  and <code class="docutils literal notranslate"><span class="pre">simplify</span></code>, then
return to (1.), except that</p></li>
<li><p>Sometimes, to output the tables, <code class="docutils literal notranslate"><span class="pre">sort</span></code>, <code class="docutils literal notranslate"><span class="pre">compute_mutation_parents</span></code>,
(optionally <code class="docutils literal notranslate"><span class="pre">simplify</span></code>), and dump these out to a file.</p></li>
</ol>
<p><em>Note:</em> as things are going along we do <em>not</em> have to
<code class="docutils literal notranslate"><span class="pre">compute_mutation_parents</span></code>, which is nice, because this is a nontrivial step
that requires construction all the trees along the sequence. Computing mutation
parents only has to happen before the final (output) step.</p>
<p>This is OK as long as the forwards-time simulation outputs things in order by when
they occur, because these operations have the following properties:</p>
<ol class="arabic simple">
<li><p>Mutations appear in the mutation table ordered by time of appearance, so
that a mutation will always appear after the one that it replaced (i.e.,
its parent).</p></li>
<li><p>Furthermore, if mutation B appears after mutation A, but at the same site,
then mutation B’s site will appear after mutation A’s site in the site
table.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> sorts sites by position, and then by ID, so that the relative
ordering of sites at the same position is maintained, thus preserving
property (2).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> sorts mutations by site, and then by ID, thus preserving property
(1); if the mutations are at separate sites (but the same position), this
fact is thanks to property (2).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">simplify</span></code> also preserves ordering of any rows in the site and mutation
tables that do not get discarded.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deduplicate_sites</span></code> goes through and collapses all sites at the same
position to only one site, maintaining order otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_mutation_parents</span></code> fills in the <code class="docutils literal notranslate"><span class="pre">parent</span></code> information by using
property (1).</p></li>
</ol>
</div>
</div>
</div>
<div class="section" id="tree-structure">
<span id="sec-data-model-tree-structure"></span><h2>Tree structure<a class="headerlink" href="#tree-structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quintuply-linked-trees">
<h3>Quintuply linked trees<a class="headerlink" href="#quintuply-linked-trees" title="Permalink to this headline">¶</a></h3>
<p>Tree structure in <code class="docutils literal notranslate"><span class="pre">tskit</span></code> is encoded internally as a “quintuply
linked tree”, a generalisation of the triply linked tree encoding
used by Knuth and others. Nodes are represented by their integer
IDs, and their relationships to other nodes are recorded in the
<code class="docutils literal notranslate"><span class="pre">parent</span></code>, <code class="docutils literal notranslate"><span class="pre">left_child</span></code>, <code class="docutils literal notranslate"><span class="pre">right_child</span></code>, <code class="docutils literal notranslate"><span class="pre">left_sib</span></code> and
<code class="docutils literal notranslate"><span class="pre">right_sib</span></code> arrays. For example, consider the following tree
and associated arrays:</p>
<a class="reference internal image-reference" href="_images/tree_structure1.svg"><img alt="An example tree" src="_images/tree_structure1.svg" width="200px" /></a>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>node</p></th>
<th class="head"><p>parent</p></th>
<th class="head"><p>left_child</p></th>
<th class="head"><p>right_child</p></th>
<th class="head"><p>left_sib</p></th>
<th class="head"><p>right_sib</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>1</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>6</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>6</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>3</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>7</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>-1</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>-1</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
</tr>
</tbody>
</table>
<p>Each node in the tree sequence corresponds to a row in this table, and
the columns are the individual arrays recording the quintuply linked
structure. Thus, we can see that the parent of nodes <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>
is <code class="docutils literal notranslate"><span class="pre">5</span></code>. Similarly, the left child of <code class="docutils literal notranslate"><span class="pre">5</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> and the
right child of <code class="docutils literal notranslate"><span class="pre">5</span></code> is <code class="docutils literal notranslate"><span class="pre">2</span></code>. The <code class="docutils literal notranslate"><span class="pre">left_sib</span></code> and <code class="docutils literal notranslate"><span class="pre">right_sib</span></code> arrays
then record each nodes sibling on its left or right, respectively;
hence the right sib of <code class="docutils literal notranslate"><span class="pre">0</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>, and the right sib of <code class="docutils literal notranslate"><span class="pre">1</span></code> is <code class="docutils literal notranslate"><span class="pre">2</span></code>.
Thus, sibling information allows us to efficiently support trees
with arbitrary numbers of children. In each of the five pointer arrays,
the null node (-1) is used to indicate the end of a path; thus,
for example, the parent of <code class="docutils literal notranslate"><span class="pre">7</span></code> and left sib of <code class="docutils literal notranslate"><span class="pre">0</span></code> are null.</p>
<p>Please see this <a class="reference internal" href="c-api.html#sec-c-api-examples-tree-traversals"><span class="std std-ref">example</span></a> for
details of how to use the quintuply linked structure in the C API.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For many applications we do not need the quintuply linked trees,
and (for example) the <code class="docutils literal notranslate"><span class="pre">left_sib</span></code> and <code class="docutils literal notranslate"><span class="pre">right_child</span></code> arrays can be
ignored. The reason for using a quintuply instead of triply linked
encoding is that it is not possible to efficiently update the trees
as we move along the sequence without the quintuply linked structure.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The left-to-right ordering of nodes is determined by the order
in which edges are inserted into the tree during iteration along the sequence.
Thus, if we arrive at the same tree by iterating from different directions,
the left-to-right ordering of nodes may be different! The specific
ordering of the children of a node should therefore not be depended on.</p>
</div>
</div>
<div class="section" id="accessing-roots">
<h3>Accessing roots<a class="headerlink" href="#accessing-roots" title="Permalink to this headline">¶</a></h3>
<p>The roots of a tree are defined as the unique endpoints of upward paths
starting from sample nodes (if no path leads upward from a sample node,
that node is also a root). Thus, trees can have multiple roots in <code class="docutils literal notranslate"><span class="pre">tskit</span></code>.
For example, if we delete the edge joining <code class="docutils literal notranslate"><span class="pre">6</span></code> and <code class="docutils literal notranslate"><span class="pre">7</span></code> in the previous
example, we get a tree with two roots:</p>
<a class="reference internal image-reference" href="_images/tree_structure2.svg"><img alt="An example tree with multiple roots" src="_images/tree_structure2.svg" width="200px" /></a>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>node</p></th>
<th class="head"><p>parent</p></th>
<th class="head"><p>left_child</p></th>
<th class="head"><p>right_child</p></th>
<th class="head"><p>left_sib</p></th>
<th class="head"><p>right_sib</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>1</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>6</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>6</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>3</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>7</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>-1</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>-1</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>-1</p></td>
<td><p>5</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
<p>To gain efficient access to the roots in the quintuply linked encoding we keep
one extra piece of information: the <code class="docutils literal notranslate"><span class="pre">left_root</span></code>. In this example
the leftmost root is <code class="docutils literal notranslate"><span class="pre">7</span></code>. Roots are considered siblings, and so
once we have one root we can find all the other roots efficiently using
the <code class="docutils literal notranslate"><span class="pre">left_sib</span></code> and <code class="docutils literal notranslate"><span class="pre">right_sib</span></code> arrays. For example, we can see here
that the right sibling of <code class="docutils literal notranslate"><span class="pre">7</span></code> is <code class="docutils literal notranslate"><span class="pre">6</span></code>, and the left sibling of <code class="docutils literal notranslate"><span class="pre">6</span></code>
is <code class="docutils literal notranslate"><span class="pre">7</span></code>.</p>
</div>
</div>
<div class="section" id="missing-data">
<span id="sec-data-model-missing-data"></span><h2>Missing data<a class="headerlink" href="#missing-data" title="Permalink to this headline">¶</a></h2>
<p>Missing data is encoded in tskit using the idea of <em>isolated samples</em>.
A sample’s genotype is missing at a position if it is <em>isolated</em> and if it has
no mutations directly above it at that position. An isolated sample is a sample
node (see <a class="reference internal" href="#sec-data-model-definitions"><span class="std std-ref">Definitions</span></a>) that has no children and no
parent, in a particular tree. This encodes the idea that we don’t know anything
about that sample’s relationships over a specific interval. This definition
covers the standard idea of missing data in genomics (where we do not know the
sequence of a given contemporary sample at some site, for whatever reason), but
also more generally the idea that we may not know anything about large sections
of the genomes of ancestral samples. However, a mutation above an isolated node
can be thought of as saying directly what the genotype is, and so renders the
genotype at that position not missing.</p>
<p>Consider the following example:</p>
<a class="reference internal image-reference" href="_images/missing_data1.svg"><img alt="A tree with an isolated sample" src="_images/missing_data1.svg" width="200px" /></a>
<p>In this tree, node 4 is isolated, and therefore for any sites that are
on this tree, the state that it is assigned is a special value
<code class="docutils literal notranslate"><span class="pre">tskit.MISSING_DATA</span></code>, or <code class="docutils literal notranslate"><span class="pre">-1</span></code>, as long as there are no mutations above
the node at that site. Note that, although isolated, because node 4
is a sample node it is still considered as being present in the
tree, meaning it will still returned by the <a class="reference internal" href="python-api.html#tskit.Tree.nodes" title="tskit.Tree.nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tree.nodes()</span></code></a> and
<a class="reference internal" href="python-api.html#tskit.Tree.samples" title="tskit.Tree.samples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tree.samples()</span></code></a> methods. The <a class="reference internal" href="python-api.html#tskit.Tree.is_isolated" title="tskit.Tree.is_isolated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tree.is_isolated()</span></code></a> method can be used to
identify nodes which are isolated samples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_isolated</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>  <span class="c1"># isolated samples in this tree</span>
<span class="go">[4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_isolated</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>  <span class="c1"># topologically connected nodes</span>
<span class="go">[0, 1, 2, 3, 5, 6, 7]</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="python-api.html#tskit.TreeSequence.variants" title="tskit.TreeSequence.variants"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TreeSequence.variants()</span></code></a> method and <a class="reference internal" href="python-api.html#tskit.Variant" title="tskit.Variant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variant</span></code></a> class for
more information on how missing data is represented in variant data.</p>
</div>
<div class="section" id="text-file-formats">
<span id="sec-text-file-format"></span><h2>Text file formats<a class="headerlink" href="#text-file-formats" title="Permalink to this headline">¶</a></h2>
<p>The tree sequence text file format is based on a simple whitespace
delimited approach. Each table corresponds to a single file, and is
composed of a number of whitespace delimited columns. The first
line of each file must be a <strong>header</strong> giving the names of each column.
Subsequent rows must contain data for each of these columns, following
the usual conventions. Each table has a set of mandatory and optional columns which are
described below. The columns can be provided in any order, and extra columns
can be included in the file. Note, in particular, that this means that
an <code class="docutils literal notranslate"><span class="pre">id</span></code> column may be present in any of these files, but it will be
ignored (IDs are always determined by the position of the row in a table).</p>
<p>We present the text format below using the following very simple tree
sequence, with four nodes, two trees, and three mutations at two sites,
both on the first tree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>time ago
--------
  3            3
            ┏━━┻━━┓
            ╋     ╋         2
            ┃     ╋      ┏━━┻━━┓
  0         0     1      0     1

position  0           7          10
</pre></div>
</div>
<p>A deletion from AT to A has occurred at position 2 on the branch leading to
node 0, and two mutations have occurred at position 4 on the branch leading to
node 1, first from A to T, then a back mutation to A. The genotypes of our two
samples, nodes 0 and 1, are therefore AA and ATA.</p>
<div class="section" id="individual-text-format">
<span id="sec-individual-text-format"></span><h3>Individual text format<a class="headerlink" href="#individual-text-format" title="Permalink to this headline">¶</a></h3>
<p>The individual text format must contain a <code class="docutils literal notranslate"><span class="pre">flags</span></code> column.
Optionally, there may also be a <code class="docutils literal notranslate"><span class="pre">location</span></code> and
<code class="docutils literal notranslate"><span class="pre">metadata</span></code> columns. See the <a class="reference internal" href="#sec-individual-table-definition"><span class="std std-ref">individual table definitions</span></a> for details on these columns.</p>
<p>Note that there are currently no globally defined <code class="docutils literal notranslate"><span class="pre">flags</span></code>, but the column
is still required; a value of <code class="docutils literal notranslate"><span class="pre">0</span></code> means that there are no flags set.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">location</span></code> column should be a sequence of comma-separated numeric
values. They do not all have to be the same length.</p>
<p>An example individual table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">flags</span>   <span class="n">location</span>
<span class="mi">0</span>           <span class="mf">0.5</span><span class="p">,</span><span class="mf">1.2</span>
<span class="mi">0</span>           <span class="mf">1.0</span><span class="p">,</span><span class="mf">3.4</span>
<span class="mi">0</span>
<span class="mi">0</span>           <span class="mf">1.2</span>
<span class="mi">0</span>           <span class="mf">3.5</span><span class="p">,</span><span class="mf">6.3</span>
<span class="mi">0</span>           <span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span>
<span class="mi">0</span>           <span class="mf">0.5</span>
<span class="mi">0</span>           <span class="mf">0.7</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.0</span>
<span class="mi">0</span>           <span class="mf">0.5</span><span class="p">,</span><span class="mf">0.0</span>
</pre></div>
</div>
</div>
<div class="section" id="node-text-format">
<span id="sec-node-text-format"></span><h3>Node text format<a class="headerlink" href="#node-text-format" title="Permalink to this headline">¶</a></h3>
<p>The node text format must contain the columns <code class="docutils literal notranslate"><span class="pre">is_sample</span></code> and
<code class="docutils literal notranslate"><span class="pre">time</span></code>. Optionally, there may also be <code class="docutils literal notranslate"><span class="pre">population</span></code>, <code class="docutils literal notranslate"><span class="pre">individual</span></code>, and
<code class="docutils literal notranslate"><span class="pre">metadata</span></code> columns. See the <a class="reference internal" href="#sec-node-table-definition"><span class="std std-ref">node table definitions</span></a> for details on these columns.</p>
<p>Note that we do not have a <code class="docutils literal notranslate"><span class="pre">flags</span></code> column in the text file format, but
instead use <code class="docutils literal notranslate"><span class="pre">is_sample</span></code> (which may be 0 or 1). Currently, <code class="docutils literal notranslate"><span class="pre">NODE_IS_SAMPLE</span></code> is
the only flag value defined for nodes, and as more flags are defined we will
allow for extra columns in the text format.</p>
<p>An example node table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">is_sample</span>   <span class="n">individual</span>   <span class="n">time</span>
<span class="mi">1</span>           <span class="mi">0</span>            <span class="mf">0.0</span>
<span class="mi">1</span>           <span class="mi">0</span>            <span class="mf">0.0</span>
<span class="mi">0</span>           <span class="o">-</span><span class="mi">1</span>           <span class="mf">1.0</span>
<span class="mi">0</span>           <span class="o">-</span><span class="mi">1</span>           <span class="mf">3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="edge-text-format">
<span id="sec-edge-text-format"></span><h3>Edge text format<a class="headerlink" href="#edge-text-format" title="Permalink to this headline">¶</a></h3>
<p>The edge text format must contain the columns <code class="docutils literal notranslate"><span class="pre">left</span></code>,
<code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">child</span></code>. Optionally, there may also be
a <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column.
See the <a class="reference internal" href="#sec-edge-table-definition"><span class="std std-ref">edge table definitions</span></a>
for details on these columns.</p>
<p>An example edge table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">left</span>   <span class="n">right</span>   <span class="n">parent</span>  <span class="n">child</span>
<span class="mf">0.0</span>    <span class="mf">7.0</span>     <span class="mi">2</span>       <span class="mi">0</span>
<span class="mf">0.0</span>    <span class="mf">7.0</span>     <span class="mi">2</span>       <span class="mi">1</span>
<span class="mf">7.0</span>    <span class="mf">10.0</span>    <span class="mi">3</span>       <span class="mi">0</span>
<span class="mf">7.0</span>    <span class="mf">10.0</span>    <span class="mi">3</span>       <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="site-text-format">
<span id="sec-site-text-format"></span><h3>Site text format<a class="headerlink" href="#site-text-format" title="Permalink to this headline">¶</a></h3>
<p>The site text format must contain the columns <code class="docutils literal notranslate"><span class="pre">position</span></code> and
<code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code>. The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column may also be optionally
present. See the
<a class="reference internal" href="#sec-site-table-definition"><span class="std std-ref">site table definitions</span></a>
for details on these columns.</p>
<p>sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">position</span>      <span class="n">ancestral_state</span>
<span class="mf">2.0</span>           <span class="n">AT</span>
<span class="mf">4.0</span>           <span class="n">A</span>
</pre></div>
</div>
</div>
<div class="section" id="mutation-text-format">
<span id="sec-mutation-text-format"></span><h3>Mutation text format<a class="headerlink" href="#mutation-text-format" title="Permalink to this headline">¶</a></h3>
<p>The mutation text format must contain the columns <code class="docutils literal notranslate"><span class="pre">site</span></code>,
<code class="docutils literal notranslate"><span class="pre">node</span></code> and <code class="docutils literal notranslate"><span class="pre">derived_state</span></code>. The <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">metadata</span></code> columns
may also be optionally present (but <code class="docutils literal notranslate"><span class="pre">parent</span></code> must be specified if
more than one mutation occurs at the same site). If <code class="docutils literal notranslate"><span class="pre">time</span></code> is absent
<code class="docutils literal notranslate"><span class="pre">UNKNOWN_TIME</span></code> will be used to fill the column. See the
<a class="reference internal" href="#sec-mutation-table-definition"><span class="std std-ref">mutation table definitions</span></a>
for details on these columns.</p>
<p>mutations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">site</span>   <span class="n">node</span>    <span class="n">derived_state</span>    <span class="n">time</span>    <span class="n">parent</span>
<span class="mi">0</span>      <span class="mi">0</span>       <span class="n">A</span>                <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>      <span class="mi">0</span>       <span class="n">T</span>                <span class="mf">0.5</span>     <span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>      <span class="mi">1</span>       <span class="n">A</span>                <span class="mi">1</span>       <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="migration-text-format">
<span id="sec-migration-text-format"></span><h3>Migration text format<a class="headerlink" href="#migration-text-format" title="Permalink to this headline">¶</a></h3>
<p>The migration text format must contain the columns <code class="docutils literal notranslate"><span class="pre">left</span></code>,
<code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">node</span></code>, <code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">dest</span></code> and <code class="docutils literal notranslate"><span class="pre">time</span></code>. The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column
may also be optionally present. See the
<a class="reference internal" href="#sec-migration-table-definition"><span class="std std-ref">migration table definitions</span></a>
for details on these columns.</p>
<p>migrations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">left</span>   <span class="n">right</span>   <span class="n">node</span>   <span class="n">source</span>   <span class="n">dest</span>   <span class="n">time</span>
<span class="mf">0.0</span>    <span class="mf">0.7</span>     <span class="mi">5</span>      <span class="mi">2</span>        <span class="mi">3</span>      <span class="mf">1.0</span>
<span class="mf">0.8</span>    <span class="mf">0.9</span>     <span class="mi">8</span>      <span class="mi">3</span>        <span class="mi">4</span>      <span class="mf">3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="population-text-format">
<span id="sec-population-text-format"></span><h3>Population text format<a class="headerlink" href="#population-text-format" title="Permalink to this headline">¶</a></h3>
<p>Population tables only have a <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column, so the text format for
a population table requires there to be a <code class="docutils literal notranslate"><span class="pre">metadata</span></code> column. See the
<a class="reference internal" href="#sec-population-table-definition"><span class="std std-ref">population table definitions</span></a> for
details.</p>
<p>An example population table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span>   <span class="n">metadata</span>
<span class="mi">0</span>    <span class="n">cG9wMQ</span><span class="o">==</span>
<span class="mi">1</span>    <span class="n">cG9wMg</span><span class="o">==</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">metadata</span></code> contains base64-encoded data (in this case, the strings
<code class="docutils literal notranslate"><span class="pre">pop1</span></code> and <code class="docutils literal notranslate"><span class="pre">pop1</span></code>).</p>
</div>
</div>
<div class="section" id="binary-interchange">
<span id="sec-binary-interchange"></span><h2>Binary interchange<a class="headerlink" href="#binary-interchange" title="Permalink to this headline">¶</a></h2>
<p>In this section we describe the high-level details of the API for interchanging
table data via numpy arrays. Please see the <a class="reference internal" href="python-api.html#sec-tables-api"><span class="std std-ref">Tables and Table Collections</span></a> for detailed
description of the functions and methods.</p>
<p>The tables API is based on <strong>columnar</strong> storage of the data. In memory, each
table is organised as a number of blocks of contiguous storage, one for
each column. There are many advantages to this approach, but the key
property for us is that allows for very efficient transfer of data
in and out of tables. Rather than inserting data into tables row-by-row
(which can be done using the <code class="docutils literal notranslate"><span class="pre">add_row</span></code> methods), it is much more
efficient to add many rows at the same time by providing pointers to blocks of
contiguous memory. By taking
this approach, we can work with tables containing gigabytes of data very
efficiently.</p>
<p>We use the <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.html">numpy Array API</a>
to allow us to define and work with numeric arrays of the required types.
Node IDs, for example, are defined using 32 bit integers. Thus, the
<code class="docutils literal notranslate"><span class="pre">parent</span></code> column of an <a class="reference internal" href="#sec-edge-table-definition"><span class="std std-ref">Edge Table</span></a>’s with <code class="docutils literal notranslate"><span class="pre">n</span></code> rows
is a block <code class="docutils literal notranslate"><span class="pre">4n</span></code> bytes.</p>
<p>This approach is very straightforward for columns in which each row contains
a fixed number of values. However, dealing with columns containing a
<strong>variable</strong> number of values is more problematic.</p>
<div class="section" id="encoding-ragged-columns">
<span id="sec-encoding-ragged-columns"></span><h3>Encoding ragged columns<a class="headerlink" href="#encoding-ragged-columns" title="Permalink to this headline">¶</a></h3>
<p>A <strong>ragged</strong> column is a column in which the rows are not of a fixed length.
For example, <a class="reference internal" href="#sec-metadata-definition"><span class="std std-ref">Metadata</span></a> columns contain binary of data of arbitrary
length. To encode such columns in the tables API, we store <strong>two</strong> columns:
one contains the flattened array of data and another stores the <strong>offsets</strong>
of each row into this flattened array. Consider an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">SiteTable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;TTT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">id      position        ancestral_state metadata</span>
<span class="go">0       0.00000000      A</span>
<span class="go">1       0.00000000</span>
<span class="go">2       0.00000000      TTT</span>
<span class="go">3       0.00000000      G</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ancestral_state</span>
<span class="go">array([65, 84, 84, 84, 71], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ancestral_state</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;ATTTG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ancestral_state_offset</span>
<span class="go">array([0, 1, 1, 4, 5], dtype=uint32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">ancestral_state_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">s</span><span class="o">.</span><span class="n">ancestral_state_offset</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;TTT&#39;</span>
</pre></div>
</div>
<p>In this example we create a <a class="reference internal" href="#sec-site-table-definition"><span class="std std-ref">Site Table</span></a> with four rows,
and then print out this table. We can see that the second row has the
empty string as its <code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code>, and the third row’s
<code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code> is <code class="docutils literal notranslate"><span class="pre">TTT</span></code>. When we print out the tables <code class="docutils literal notranslate"><span class="pre">ancestral_state</span></code>
column, we see that its a numpy array of length 5: this is the
flattened array of <a class="reference external" href="https://en.wikipedia.org/wiki/ASCII">ASCII encoded</a>
values for these rows. When we decode these bytes using the
numpy <code class="docutils literal notranslate"><span class="pre">tobytes</span></code> method, we get the string ‘ATTTG’. This flattened array
can now be transferred efficiently in memory like any other column. We
then use the <code class="docutils literal notranslate"><span class="pre">ancestral_state_offset</span></code> column to allow us find the
individual rows. For a row <code class="docutils literal notranslate"><span class="pre">j</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ancestral_state</span><span class="p">[</span><span class="n">ancestral_state_offset</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="n">ancestral_state_offset</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>gives us the array of bytes for the ancestral state in that row.</p>
<p>For a table with <code class="docutils literal notranslate"><span class="pre">n</span></code> rows, any offset column must have <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>
values, the first of which is always <code class="docutils literal notranslate"><span class="pre">0</span></code>. The values in this column must be
nondecreasing, and cannot exceed the length of the ragged column in question.</p>
</div>
</div>
<div class="section" id="tree-sequence-file-format">
<span id="sec-tree-sequence-file-format"></span><h2>Tree sequence file format<a class="headerlink" href="#tree-sequence-file-format" title="Permalink to this headline">¶</a></h2>
<p>To make tree sequence data as efficient and easy as possible to use, we store the
data on file in a columnar, binary format. The format is based on the
<a class="reference external" href="https://pypi.org/project/kastore/">kastore</a> package, which is a simple
key-value store for numerical data. There is a one-to-one correspondence
between the tables described above and the arrays stored in these files.</p>
<p>By convention, these files are given the <code class="docutils literal notranslate"><span class="pre">.trees</span></code> suffix (although this
is not enforced in any way), and we will sometimes refer to them as “.trees”
files. We also refer to them as “tree sequence files”.</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Link to the documentation for kastore, and describe the arrays that are
stored as well as the top-level metadata.</p>
</div>
<div class="section" id="legacy-versions">
<h3>Legacy Versions<a class="headerlink" href="#legacy-versions" title="Permalink to this headline">¶</a></h3>
<p>Tree sequence files written by older versions of tskit are not readable by
newer versions of tskit. For major releases of tskit, <code class="docutils literal notranslate"><span class="pre">tskit</span> <span class="pre">upgrade</span></code>
will convert older tree sequence files to the latest version.</p>
<p>File formats from version 11 onwards are based on
<a class="reference external" href="https://pypi.org/project/kastore/">kastore</a>;
previous to this, the file format was based on HDF5.</p>
<p>However many changes to the tree sequence format are not part of major
releases. The table below gives these versions.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Version number</p></th>
<th class="head"><p>Commit Short Hash</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>11.0</p></td>
<td><p>5646cd3</p></td>
</tr>
<tr class="row-odd"><td><p>10.0</p></td>
<td><p>e4396a7</p></td>
</tr>
<tr class="row-even"><td><p>9.0</p></td>
<td><p>e504abd</p></td>
</tr>
<tr class="row-odd"><td><p>8.0</p></td>
<td><p>299ddc9</p></td>
</tr>
<tr class="row-even"><td><p>7.0</p></td>
<td><p>ca9c0c5</p></td>
</tr>
<tr class="row-odd"><td><p>6.0</p></td>
<td><p>6310725</p></td>
</tr>
<tr class="row-even"><td><p>5.0</p></td>
<td><p>62659fb</p></td>
</tr>
<tr class="row-odd"><td><p>4.0</p></td>
<td><p>a586646</p></td>
</tr>
<tr class="row-even"><td><p>3.2</p></td>
<td><p>8f44bed</p></td>
</tr>
<tr class="row-odd"><td><p>3.1</p></td>
<td><p>d69c059</p></td>
</tr>
<tr class="row-even"><td><p>3.0</p></td>
<td><p>7befdcf</p></td>
</tr>
<tr class="row-odd"><td><p>2.1</p></td>
<td><p>a26a227</p></td>
</tr>
<tr class="row-even"><td><p>2.0</p></td>
<td><p>7c507f3</p></td>
</tr>
<tr class="row-odd"><td><p>1.1</p></td>
<td><p>c143dd9</p></td>
</tr>
<tr class="row-even"><td><p>1.0</p></td>
<td><p>04722d8</p></td>
</tr>
<tr class="row-odd"><td><p>0.3</p></td>
<td><p>f42215e</p></td>
</tr>
<tr class="row-even"><td><p>0.1</p></td>
<td><p>34ac742</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="metadata.html" class="btn btn-neutral float-right" title="Metadata" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cli.html" class="btn btn-neutral float-left" title="Command line interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018-2020, Tskit developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>